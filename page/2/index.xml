<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蒟蒻的博客</title>
    <link>https://seraphim.rocks/</link>
    <description>Recent content on 蒟蒻的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Feb 2020 21:55:41 +0800</lastBuildDate>
    
        <atom:link href="https://seraphim.rocks/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>用markdown做slides</title>
        <link>https://seraphim.rocks/posts/mdslide/</link>
        <pubDate>Sat, 15 Dec 2018 21:43:39 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/mdslide/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/mdslide/ -&lt;p&gt;厚颜无耻地把自己的项目发上来.&lt;/p&gt;
&lt;p&gt;其实也没写什么东西，就是把&lt;code&gt;reveal.js&lt;/code&gt;封装了一下. 这样就可以比较方便地用markdown直接写，也可以一条命令导出，方便在其他电脑上播放.&lt;/p&gt;
&lt;p&gt;暂时还没有写文档，也许会在有生之年补上.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/jwhj/mdslide&#34;&gt;项目地址&lt;/a&gt;&lt;/p&gt;- https://seraphim.rocks/posts/mdslide/ - </description>
        </item>
    
    
    
        <item>
        <title>whj什么都不会系列-1</title>
        <link>https://seraphim.rocks/posts/sbwhj-1/</link>
        <pubDate>Fri, 14 Dec 2018 21:40:41 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/sbwhj-1/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/sbwhj-1/ -&lt;p&gt;退役了只有一直没怎么做题，感觉水平退步了不少，以前一些比较显然的思路现在可能都想不到了. 这样下去肯定是不行的，我尽量时不时做点&lt;del&gt;水&lt;/del&gt;题写点题解恢复一点智商吧.&lt;/p&gt;
&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;
&lt;p&gt;给定&lt;span class=&#34;math inline&#34;&gt;\(n,m\)&lt;/span&gt;，求有多少对&lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt;满足&lt;span class=&#34;math inline&#34;&gt;\(1\le i\le n,1\le j\le m\)&lt;/span&gt;且&lt;span class=&#34;math inline&#34;&gt;\(\gcd(i,j)\)&lt;/span&gt;为素数.&lt;/p&gt;
&lt;p&gt;共&lt;span class=&#34;math inline&#34;&gt;\(T\)&lt;/span&gt;组数据.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(n\le 10^7,T\le 10^4\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;解&#34;&gt;解&lt;/h3&gt;
&lt;p&gt;记&lt;span class=&#34;math inline&#34;&gt;\(f(n,m)=\sum _{i=1}^n\sum _{j=1}^m[i\perp j]\)&lt;/span&gt;，显然答案就是&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
下面看$f$怎么算. 如果$n=m$，显然有$f(n,n)=\sum _{i=1}^n\varphi(n)$，预处理欧拉函数前缀和就可以做了.

$n\neq m$的时候一个显然的套路就是莫比乌斯反演：

$$\begin{aligned}
f(n,m)=&amp;\sum _{i}\sum _{j}\sum _{d|\gcd(i,j)}\mu(d)\\
=&amp;\sum _{d}\mu(d) [n/d] [m/d]
\end{aligned}$$

用整除分块可以做到$\mathcal O(\sqrt{n})$的复杂度，从而每次询问是$\mathcal O(n^{3/4})$， 但这还是太慢了.

~~前面都是废话.~~

$f$本身的计算已经没什么办法优化了，考虑代入$f([n/p],[m/p])$，得到

$$\begin{aligned}
\sum _{p\text{ is prime}}f([n/p],[m/p])=&amp;\sum _{p\text{ is prime}}\sum\mu(d) [n/(pd)] [m/(pd)]\\
=&amp;\sum _{T}[n/T] [m/T]\sum _{p|T,p\text{ is prime}}\mu(T/p)
\end{aligned}$$

记$g(T)=\sum _{p|T,p\text{ is prime}}\mu(T/p)$，观察一下可以发现$g(n)$很有规律.

记$s _1(n),s _2(n)$分别为$n$的不同素因数个数和歌素因数的指数和，那么当$s _1(n)=s _2(n)$时，$g(T)=-s _1(n)(-1)^{s _1(n)}$，当$s _1(n)+1=s _2(n)$时，$g(T)=(-1)^{s _1(n)}$，当$s _1(n)+2\le s _2(n)$时，$g(T)=0$.

于是就可以很容易地处理$g(n)$的前缀和，进而$\mathcal O(\sqrt{n})$地处理每次询问.
\]&lt;/span&gt;&lt;/p&gt;- https://seraphim.rocks/posts/sbwhj-1/ - </description>
        </item>
    
    
    
        <item>
        <title>O(1)快速乘</title>
        <link>https://seraphim.rocks/posts/fastmul/</link>
        <pubDate>Fri, 30 Nov 2018 22:19:28 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/fastmul/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/fastmul/ -&lt;p&gt;AFO有段时间了，感觉自己什么都不会了，随便研究点东西证明我还活着……&lt;/p&gt;
&lt;p&gt;众所周知在long long乘long long模long long的时候，直接乘会溢出，所以要用一些技巧来处理. 一般的快速乘是&lt;span class=&#34;math inline&#34;&gt;\(O(\log x)\)&lt;/span&gt;的，所以我们也可以叫它慢速乘. 事实上可以用一些技巧做到&lt;span class=&#34;math inline&#34;&gt;\(O(1)\)&lt;/span&gt;，实现真正的快速乘.&lt;/p&gt;
&lt;p&gt;首先我们知道&lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;模&lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;可以表示为&lt;span class=&#34;math inline&#34;&gt;\(a-b\lfloor a/b\rfloor\)&lt;/span&gt;，于是如果我们要计算&lt;span class=&#34;math inline&#34;&gt;\(a\times b\)&lt;/span&gt;对&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt;取模的结果，可以考虑计算&lt;span class=&#34;math inline&#34;&gt;\(ab-m\lfloor(a/m)*b\rfloor\)&lt;/span&gt;. 写出下面的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;%=&lt;/span&gt;MOD; b&lt;span style=&#34;color:#f92672&#34;&gt;%=&lt;/span&gt;MOD;
ele d&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;)a&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;MOD&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5&lt;/span&gt;;
ele tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;d&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;MOD;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (tmp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) tmp&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;MOD;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的&lt;code&gt;a*b&lt;/code&gt;和&lt;code&gt;d*MOD&lt;/code&gt;显然都会溢出，不过可以注意到，溢出只会使结果差&lt;span class=&#34;math inline&#34;&gt;\(2^{64}\)&lt;/span&gt;的整数倍，而模出来的结果显然不到&lt;span class=&#34;math inline&#34;&gt;\(2^{64}\)&lt;/span&gt;所以一定是对的.&lt;/p&gt;
&lt;p&gt;不过这里有一个小问题，为了防止炸精度，我们加了&lt;span class=&#34;math inline&#34;&gt;\(0.5\)&lt;/span&gt;来四舍五入，而不是向下取整，最后的结果可能会少一个&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt;，所以最后要判断一下，如果&lt;code&gt;tmp&amp;lt;0&lt;/code&gt;就要&lt;code&gt;tmp+=MOD&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;另外的话如果&lt;span class=&#34;math inline&#34;&gt;\(a\ge m\)&lt;/span&gt;或者&lt;span class=&#34;math inline&#34;&gt;\(b\ge m\)&lt;/span&gt;可能会挂，所以一开始的时候要模一下.&lt;/p&gt;
&lt;p&gt;简化的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; ele &lt;span style=&#34;color:#a6e22e&#34;&gt;mul&lt;/span&gt;(ele a,ele b,ele MOD){
	a&lt;span style=&#34;color:#f92672&#34;&gt;%=&lt;/span&gt;MOD; b&lt;span style=&#34;color:#f92672&#34;&gt;%=&lt;/span&gt;MOD;
	ele tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(ele)((&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;)a&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;MOD&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.5&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;MOD;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; tmp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;tmp&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;MOD:tmp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://seraphim.rocks/posts/fastmul/ - </description>
        </item>
    
    
    
        <item>
        <title>黑科技</title>
        <link>https://seraphim.rocks/posts/%E9%BB%91%E7%A7%91%E6%8A%80/</link>
        <pubDate>Sun, 30 Sep 2018 21:43:03 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/%E9%BB%91%E7%A7%91%E6%8A%80/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/%E9%BB%91%E7%A7%91%E6%8A%80/ -&lt;p&gt;好久没写博客了，随便扔点东西上来除个草.&lt;/p&gt;
&lt;p&gt;其实也说不上是黑科技，就是自己平时折腾linux，折腾vim之类的东西的时候发现的一些小技巧罢了.&lt;/p&gt;
&lt;h3 id=&#34;esc键太远&#34;&gt;esc键太远&lt;/h3&gt;
&lt;p&gt;平时用vim的时候经常要用到esc键，vim的设计理念本来是让手不用离开主键区，&lt;del&gt;但是esc似乎就在主键区之外&lt;/del&gt;. 事实上vim刚被开发出来那会的键盘和现在是不一样的，那个时候esc还在主键区里面. 解决这个东西的方法有几个，我用的方法是把esc和caps lock调换一下，只需要在&lt;code&gt;~/.xprofile&lt;/code&gt;里面加上这样一行代码（应该只对linux有效）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setxkbmap -option caps:swapescape
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;vim配置文件&#34;&gt;vim配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;set autoindent
set tabstop=4
set shiftwidth=4
set noexpandtab
let g:python_recommended_style=0
set nu
set backspace=2
set mouse=a
syntax on
colorscheme desert

map &amp;lt;space&amp;gt; :
nnoremap j gj
vnoremap j gj
nnoremap k gk
vnoremap k gk
map JJ &amp;lt;esc&amp;gt;
imap JJ &amp;lt;esc&amp;gt;
map JK g$
map KJ g^
imap JK &amp;lt;esc&amp;gt;lg$a
imap KJ &amp;lt;esc&amp;gt;hg^i

map &amp;lt;f7&amp;gt; :%s/[\u4E00-\u9FCC]//gn&amp;lt;cr&amp;gt;

function! P1()
	:%s/\\\\\\{/\\{/g
	:%s/\\\\\\}/\\}/g
	:%s/\\\\\\\\/\\\\/g
endfunction

function! P2()
	:%s/\\\\/\\\\\\\\/g
	:%s/\\{/\\\\\\{/g
	:%s/\\}/\\\\\\}/g
endfunction

call plug#begin(&#39;~/.vim/plugged&#39;)
Plug &#39;godlygeek/tabular&#39;
Plug &#39;plasticboy/vim-markdown&#39;
Plug &#39;iamcco/markdown-preview.vim&#39;
Plug &#39;iamcco/mathjax-support-for-mkdp&#39;
Plug &#39;vim-scripts/fcitx.vim&#39;
Plug &#39;Shougo/neocomplete.vim&#39;
call plug#end()

autocmd filetype markdown set shell=bash\ -i
let g:instant_markdown_autostart=0
&amp;quot; let g:instant_markdown_slow=1

let g:vim_markdown_folding_disabled=1

&amp;quot;Note: This option must be set in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
&amp;quot; Disable AutoComplPop.
let g:acp_enableAtStartup = 0
&amp;quot; Use neocomplete.
let g:neocomplete#enable_at_startup = 1
&amp;quot; Use smartcase.
let g:neocomplete#enable_smart_case = 1
&amp;quot; Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3

&amp;quot; Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ &#39;default&#39; : &#39;&#39;,
    \ &#39;vimshell&#39; : $HOME.&#39;/.vimshell_hist&#39;,
    \ &#39;scheme&#39; : $HOME.&#39;/.gosh_completions&#39;
        \ }

&amp;quot; Define keyword.
if !exists(&#39;g:neocomplete#keyword_patterns&#39;)
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns[&#39;default&#39;] = &#39;\h\w*&#39;

&amp;quot; Plugin key-mappings.
inoremap &amp;lt;expr&amp;gt;&amp;lt;C-g&amp;gt;     neocomplete#undo_completion()
inoremap &amp;lt;expr&amp;gt;&amp;lt;C-l&amp;gt;     neocomplete#complete_common_string()

&amp;quot; Recommended key-mappings.
&amp;quot; &amp;lt;CR&amp;gt;: close popup and save indent.
inoremap &amp;lt;silent&amp;gt; &amp;lt;CR&amp;gt; &amp;lt;C-r&amp;gt;=&amp;lt;SID&amp;gt;my_cr_function()&amp;lt;CR&amp;gt;
function! s:my_cr_function()
  return (pumvisible() ? &amp;quot;\&amp;lt;C-y&amp;gt;&amp;quot; : &amp;quot;&amp;quot; ) . &amp;quot;\&amp;lt;CR&amp;gt;&amp;quot;
  &amp;quot; For no inserting &amp;lt;CR&amp;gt; key.
  &amp;quot;return pumvisible() ? &amp;quot;\&amp;lt;C-y&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;CR&amp;gt;&amp;quot;
endfunction
&amp;quot; &amp;lt;TAB&amp;gt;: completion.
inoremap &amp;lt;expr&amp;gt;&amp;lt;TAB&amp;gt;  pumvisible() ? &amp;quot;\&amp;lt;C-n&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;TAB&amp;gt;&amp;quot;
&amp;quot; &amp;lt;C-h&amp;gt;, &amp;lt;BS&amp;gt;: close popup and delete backword char.
inoremap &amp;lt;expr&amp;gt;&amp;lt;C-h&amp;gt; neocomplete#smart_close_popup().&amp;quot;\&amp;lt;C-h&amp;gt;&amp;quot;
inoremap &amp;lt;expr&amp;gt;&amp;lt;BS&amp;gt; neocomplete#smart_close_popup().&amp;quot;\&amp;lt;C-h&amp;gt;&amp;quot;
&amp;quot; Close popup by &amp;lt;Space&amp;gt;.
&amp;quot;inoremap &amp;lt;expr&amp;gt;&amp;lt;Space&amp;gt; pumvisible() ? &amp;quot;\&amp;lt;C-y&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;Space&amp;gt;&amp;quot;

&amp;quot; AutoComplPop like behavior.
&amp;quot;let g:neocomplete#enable_auto_select = 1

&amp;quot; Shell like behavior(not recommended).
&amp;quot;set completeopt+=longest
&amp;quot;let g:neocomplete#enable_auto_select = 1
&amp;quot;let g:neocomplete#disable_auto_complete = 1
&amp;quot;inoremap &amp;lt;expr&amp;gt;&amp;lt;TAB&amp;gt;  pumvisible() ? &amp;quot;\&amp;lt;Down&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;C-x&amp;gt;\&amp;lt;C-u&amp;gt;&amp;quot;

&amp;quot; Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

&amp;quot; Enable heavy omni completion.
if !exists(&#39;g:neocomplete#sources#omni#input_patterns&#39;)
  let g:neocomplete#sources#omni#input_patterns = {}
endif
&amp;quot;let g:neocomplete#sources#omni#input_patterns.php = &#39;[^. \t]-&amp;gt;\h\w*\|\h\w*::&#39;
&amp;quot;let g:neocomplete#sources#omni#input_patterns.c = &#39;[^.[:digit:] *\t]\%(\.\|-&amp;gt;\)&#39;
&amp;quot;let g:neocomplete#sources#omni#input_patterns.cpp = &#39;[^.[:digit:] *\t]\%(\.\|-&amp;gt;\)\|\h\w*::&#39;

&amp;quot; For perlomni.vim setting.
&amp;quot; https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = &#39;\h\w*-&amp;gt;\h\w*\|\h\w*::&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果只是要用于OI比赛的话，应该只需要前面的一部分.&lt;/p&gt;
&lt;p&gt;希望很久以后我还能看得懂这份配置文件，懒得没修改一次就重新写一次解释了.&lt;/p&gt;- https://seraphim.rocks/posts/%E9%BB%91%E7%A7%91%E6%8A%80/ - </description>
        </item>
    
    
    
        <item>
        <title>NOI2018退役记</title>
        <link>https://seraphim.rocks/posts/farewelloi/</link>
        <pubDate>Sat, 01 Sep 2018 21:34:49 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/farewelloi/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/farewelloi/ -&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;退役之后一直有点消沉，没有写退役记什么的，最近想了想还是多少放点东西上来.&lt;/p&gt;
&lt;p&gt;考挂了的原因有很多，各种意外，和同层次的选手缺少交流等等，或者可以说我觉得自己有进队的实力，但是没有稳进队的实力.&lt;/p&gt;
&lt;p&gt;不过现在再说这些东西意义也没什么意义，丢掉的分不会再回来，我总归还是退役了.&lt;/p&gt;
&lt;p&gt;其实回过头来想想，我也算是比很多人走得远了. 况且，就算我进了队，再多苟半年一年终究是要退役. 所以真的也没什么必要耿耿于怀，只是时不时回想起来，总觉得太过遗憾. 但人生总是要有些不如意的事情，或许十几年过后，再回想起来，这也不过是一件小事.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;幻梦终醒，本无不散之筵席，却不悔付此华年.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这不是开始，也远未结束.&lt;/p&gt;
&lt;/blockquote&gt;- https://seraphim.rocks/posts/farewelloi/ - </description>
        </item>
    
    
    
        <item>
        <title>uoj50题解</title>
        <link>https://seraphim.rocks/posts/uoj50/</link>
        <pubDate>Fri, 17 Aug 2018 19:28:08 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/uoj50/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/uoj50/ -&lt;p&gt;分治fft是非常明显的做法，不过这样是&lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n\log^2n)\)&lt;/span&gt;的. 把生成函数弄出来之后会发现它是个微分方程，可以有一些神奇的方法来解，具体可以看UR3的题解.&lt;/p&gt;
&lt;p&gt;我比较菜所以还是决定写分治+卡常，发现了一个卡常技巧. 对&lt;span class=&#34;math inline&#34;&gt;\([l,r)\)&lt;/span&gt;区间分治的时候，设&lt;span class=&#34;math inline&#34;&gt;\(m=\left\lfloor\frac{l+r}{2}\right\rfloor\)&lt;/span&gt;，如果&lt;span class=&#34;math inline&#34;&gt;\(l\neq0\)&lt;/span&gt;，就要把&lt;span class=&#34;math inline&#34;&gt;\(C(z)\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(F(z)\)&lt;/span&gt;在&lt;span class=&#34;math inline&#34;&gt;\([l,m)\)&lt;/span&gt;的部分，&lt;span class=&#34;math inline&#34;&gt;\(F(z)\)&lt;/span&gt;在&lt;span class=&#34;math inline&#34;&gt;\([0,r-l)\)&lt;/span&gt;的部分卷起来，这里fft的长度看似要开到&lt;span class=&#34;math inline&#34;&gt;\(4(r-l)\)&lt;/span&gt;，但事实上只需要开到&lt;span class=&#34;math inline&#34;&gt;\(2(r-l)\)&lt;/span&gt;，因为超出&lt;span class=&#34;math inline&#34;&gt;\(2(r-l)\)&lt;/span&gt;的部分小于&lt;span class=&#34;math inline&#34;&gt;\(2(r-l)+(m-l)\)&lt;/span&gt;，这样就算循环到前面去，也会小于&lt;span class=&#34;math inline&#34;&gt;\(m-l\)&lt;/span&gt;，而对&lt;span class=&#34;math inline&#34;&gt;\([m,r)\)&lt;/span&gt;的贡献是从&lt;span class=&#34;math inline&#34;&gt;\(m-l\)&lt;/span&gt;开始的，所以不影响答案. 而&lt;span class=&#34;math inline&#34;&gt;\(l=0\)&lt;/span&gt;的时候fft长度显然也可以只开到&lt;span class=&#34;math inline&#34;&gt;\(2(r-l)\)&lt;/span&gt;. 这样一来可以显著减小常数. &lt;del&gt;跑得比网上搜到的倍增还快！&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;另外以后在我学会倍增解微分方程之前，看到微分方程不会解可以考虑分治.&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define ele int
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define ll long long
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; ele maxn&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; ele MOD&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;998244353&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; ele G&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; ele inv2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(MOD&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; add(ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a,ele b){
	a&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;b;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt;MOD&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt;MOD:a;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; ele &lt;span style=&#34;color:#a6e22e&#34;&gt;pw&lt;/span&gt;(ele a,ele x){
	ele ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (; x; x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)tmp&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)ans&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
}
ele n,f[maxn],g[maxn],c[maxn],inv[maxn],fac[maxn],ifac[maxn];
&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; s[maxn];
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ntt&lt;/span&gt;(ele K,ele n,ele &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;y){
	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; ele f[maxn];
	f[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i){
		f[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;f[i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) f[i]&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;f[i]) swap(y[i],y[f[i]]);
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; p&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; p&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
		ele o&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pw(G,(MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;); o&lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt;K&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;o:pw(o,MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; i&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;(p&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)){
			ele o1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;i; j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;j,o1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)o1&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;o&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD){
				ele v&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)y[j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;o1&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
				y[j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;y[j];
				add(y[j],v); add(y[j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p],MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;v);
			}
		}
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!~&lt;/span&gt;K){
		ele invn&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pw(n,MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) y[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)y[i]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;invn&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	}
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solve&lt;/span&gt;(ele l,ele r){
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
		f[l&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)g[l]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;inv[l&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
	}
	ele mid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(l&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;r)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; ele t1[maxn],t2[maxn],t3[maxn];
	solve(l,mid);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (l){
		ele tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		memset(t1,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp); memcpy(t1,c,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l));
		memset(t2,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp); memcpy(t2,f&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;l,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(mid&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l));
		memset(t3,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp); memcpy(t3,f,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l));
		ntt(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t1); ntt(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t2); ntt(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t3);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;tmp; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;t2[i]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;t3[i]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
		ntt(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t1);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;mid; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;r; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) add(g[i],t1[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l]);
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;{
		ele tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		memset(t1,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp); memcpy(t1,c,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l));
		memset(t2,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp); memcpy(t2,f&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;l,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(mid&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l));
		ntt(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t1); ntt(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t2);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;tmp; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i){
			t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;t2[i]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;t2[i]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
			t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;(t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;MOD)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		}
		ntt(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t1);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;mid; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;r; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) add(g[i],t1[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;l]);
	}
	solve(mid,r);
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
	scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d%s&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;n,s);
	ele tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (tmp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n) tmp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	fac[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;tmp; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) fac[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)fac[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	ifac[tmp]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pw(fac[tmp],MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tmp&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;i; &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;i) ifac[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)ifac[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;tmp; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) inv[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)fac[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ifac[i]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i){
		c[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;s[i]&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
		c[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;c[i]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ifac[i];
	}
	g[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	solve(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,tmp);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
		printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%lld&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,(ll)f[i]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fac[i]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://seraphim.rocks/posts/uoj50/ - </description>
        </item>
    
    
    
        <item>
        <title>loj2541题解</title>
        <link>https://seraphim.rocks/posts/loj2541/</link>
        <pubDate>Mon, 16 Jul 2018 15:47:07 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/loj2541/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/loj2541/ -&lt;p&gt;这种求某个东西在最后一个的概率之类的其实可以考虑容斥，设钦定一个集合&lt;span class=&#34;math inline&#34;&gt;\(S\)&lt;/span&gt;在它后面的概率为&lt;span class=&#34;math inline&#34;&gt;\(f(S)\)&lt;/span&gt;，那么最后的答案为&lt;span class=&#34;math inline&#34;&gt;\(\sum (-1)^{|S|}f(S)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;现在考虑怎么算&lt;span class=&#34;math inline&#34;&gt;\(f(S)\)&lt;/span&gt;，一种感性的方法是，你可以认为其他人就没有关系了，那么&lt;span class=&#34;math inline&#34;&gt;\(f(S)\)&lt;/span&gt;即为第一个人第一个死的概率，即&lt;span class=&#34;math inline&#34;&gt;\(\frac{w _1}{w _1+\text{sum}(S)}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;要严谨地证明的话，可以改变一下游戏规则：死去的人不把他踢出去，这样不会改变每个人的死亡顺序，记&lt;span class=&#34;math inline&#34;&gt;\(W=\sum _{i=1}^n w _i\)&lt;/span&gt;，那么&lt;span class=&#34;math inline&#34;&gt;\(f(S)=\sum _{i=0}^{+\infty}\left(\frac{W-w _1-\text{sum}(S)}{W}\right)^i\frac{w _1}{W}=\frac{w _1}{w _1+\text{sum}(S)}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;于是答案就是&lt;span class=&#34;math inline&#34;&gt;\(\sum \frac{(-1)^{|S|}}{w _1+\text{sum}(S)}\)&lt;/span&gt;，注意到&lt;span class=&#34;math inline&#34;&gt;\(w _i\)&lt;/span&gt;加起来很小，我们可以统计每个&lt;span class=&#34;math inline&#34;&gt;\(\text{sum}(S)\)&lt;/span&gt;的贡献，这个只需要计算&lt;span class=&#34;math inline&#34;&gt;\(\prod _{i=2}^n(1-z^{w _i})\)&lt;/span&gt;就可以了.&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define ele int
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define ll long long
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; ele maxn&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;#define MOD 998244353
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define G 3
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; add(ele &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a,ele b){
	a&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;b;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt;MOD&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt;MOD:a;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; ele &lt;span style=&#34;color:#a6e22e&#34;&gt;pw&lt;/span&gt;(ele a,ele x){
	ele ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (; x; x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)tmp&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)ans&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
}
ele n,w[maxn],a[maxn];
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ntt&lt;/span&gt;(ele K,ele n,ele &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;y){
	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; ele f[maxn];
	f[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i){
		f[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;f[i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) f[i]&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;f[i]) swap(y[i],y[f[i]]);
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; p&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; p&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
		ele o&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pw(G,(MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;); o&lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt;K&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;o:pw(o,MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; i&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;(p&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)){
			ele o1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;i; j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;j,o1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)o1&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;o&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD){
				ele u&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;y[j],v&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)y[j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;o1&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
				y[j]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;y[j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;u;
				add(y[j],v); add(y[j&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;p],MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;v);
			}
		}
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!~&lt;/span&gt;K){
		ele invn&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pw(n,MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) y[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)y[i]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;invn&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	}
}
ele &lt;span style=&#34;color:#a6e22e&#34;&gt;solve&lt;/span&gt;(ele &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a,ele l,ele r){
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (l&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;r){
		a[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		a[w[l]]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;w[l]; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) a[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; w[l];
	}
	ele mid&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(l&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;r)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	ele s1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;solve(a,l,mid);
	ele s2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;solve(a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,mid&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,r);
	ele tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (tmp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;s1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s2) tmp&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; ele t1[maxn],t2[maxn];
	memset(t1,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp); memcpy(t1,a,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(s1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
	memset(t2,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp); memcpy(t2,a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(s2&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
	ntt(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t1); ntt(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t2);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;tmp; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(ll)t1[i]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;t2[i]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD;
	ntt(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,tmp,t1);
	memcpy(a,t1,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(ele)&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(s1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s2&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; s1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s2;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
	scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;n);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,w&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;i);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
		ele s&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;solve(a,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
		ele ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;s; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) add(ans,(ll)w[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a[i]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pw(w[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;i,MOD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;MOD);
		printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,ans);
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; puts(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://seraphim.rocks/posts/loj2541/ - </description>
        </item>
    
    
    
        <item>
        <title>uoj387题解</title>
        <link>https://seraphim.rocks/posts/uoj387/</link>
        <pubDate>Sun, 15 Jul 2018 13:31:44 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/uoj387/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/uoj387/ -&lt;p&gt;学到了一个新的技巧，树形的依赖关系，把顺序翻转，就可以在依赖父亲和依赖子树之间相互转化.&lt;/p&gt;
&lt;p&gt;每次选取最深的能选取的叶子，证明的话，画个图用一下调整法应该能证.&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define ele int
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define fi first
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define se second
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#75715e&#34;&gt;#define maxn 100010
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;ele n,m,ans,f[maxn],dep[maxn],deg[maxn];
vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; res[maxn];
priority_queue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ele,ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Q;
queue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Q1;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
	scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d%d&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;n,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;m);
	dep[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
	memset(deg,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(deg));
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i){
		scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,f&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;i);
		&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;f[i]; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;deg[f[i]];
		dep[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;dep[f[i]]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;deg[i]) Q.push(make_pair(dep[i],i));
	ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i){
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Q.empty()){
			&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;ans;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;Q1.empty()){
				ele k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Q1.front(); Q1.pop();
				Q.push(make_pair(dep[k],k));
			}
		}
		pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ele,ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; k1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Q.top(); Q.pop();
		ele k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;k1.se;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (res[ans].size()&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;m){
			&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;ans;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;Q1.empty()){
				ele k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Q1.front(); Q1.pop();
				Q.push(make_pair(dep[k],k));
			}
		}
		res[ans].push_back(k);
		&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;deg[f[k]];
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;deg[f[k]]) Q1.push(f[k]);
	}
	printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,ans&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ans; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;i; &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;i){
		printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;,res[i].size());
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;res[i].size()&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;j; &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;j) printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;,res[i][j]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
		puts(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;);
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://seraphim.rocks/posts/uoj387/ - </description>
        </item>
    
    
    
        <item>
        <title>bzoj2324题解</title>
        <link>https://seraphim.rocks/posts/bzoj2324/</link>
        <pubDate>Sat, 07 Jul 2018 20:49:50 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/bzoj2324/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/bzoj2324/ -&lt;p&gt;前置技能：DAG的最小路径覆盖和最小链覆盖.&lt;/p&gt;
&lt;p&gt;算了还是写一下吧免得自己忘了.&lt;/p&gt;
&lt;p&gt;最小路径覆盖的做法就是把每个点&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;拆成两个点&lt;span class=&#34;math inline&#34;&gt;\(i _0,i _1\)&lt;/span&gt;，边&lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt;变成&lt;span class=&#34;math inline&#34;&gt;\((i _0,j _1)\)&lt;/span&gt;，然后做最大匹配，这样每条匹配边相当于原图中一条边，匹配保证了每个点最多有一条入边一条出边，答案就是原图点数-匹配数，因为你可以看成每个点先独立为一条路径，每加入一条边相当于合并两条路径.&lt;/p&gt;
&lt;p&gt;最小链覆盖的话边可以相交，所以需要先用floyd传递闭包，其实就是对于所有点对&lt;span class=&#34;math inline&#34;&gt;\((i,j)\)&lt;/span&gt;求出是否有一条链从&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;到&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;，有的话直接连一条边过去，这样两条链相交的话其中一条就可以直接跳过交点.&lt;/p&gt;
&lt;p&gt;题目可以认为是用&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;条可相交的路径去覆盖这张图，满足一些条件，让边权和最小.&lt;/p&gt;
&lt;p&gt;因为可相交，先考虑来一发传递闭包，因为题目要求，状态要改成&lt;span class=&#34;math inline&#34;&gt;\(g _{i,j}\)&lt;/span&gt;表示只经过编号不超过&lt;span class=&#34;math inline&#34;&gt;\(\max(i,j)\)&lt;/span&gt;的点，从&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;到&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;的最短路，然后对所有&lt;span class=&#34;math inline&#34;&gt;\(i\lt j\)&lt;/span&gt;，以&lt;span class=&#34;math inline&#34;&gt;\(g _{i,j}\)&lt;/span&gt;为权值连边.&lt;/p&gt;
&lt;p&gt;这样题目就变成了用&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;条只在&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;号点相交的路径去覆盖这张图，然后就能够按照DAG最小路径覆盖来建图了，需要注意的是，源点连向&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;号点的入点的边容量为&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;，因为这&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;条路径能在&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;处相交即&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;号点出去的边最多可以选&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;条. 边的费用当然就是&lt;span class=&#34;math inline&#34;&gt;\(g _{i,j}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define ele int
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define fi first
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define se second
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#75715e&#34;&gt;#define maxn 310
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define maxm 20010
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; ele INF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1e9&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;edge&lt;/span&gt;{
	ele v,r,c;
	edge &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;nxt,&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;rev;
}ep[&lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;],&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ecnt;
ele n,m,K,g[maxn][maxn],d[maxn];
&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; vis[maxn];
edge &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;h[maxn],&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;cur[maxn];
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addedge1&lt;/span&gt;(ele u,ele v,ele r,ele c){
	edge &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ecnt&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
	p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;v&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;v; p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;r&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r; p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;c; p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;nxt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;h[u]; p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;rev&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ep&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;((ecnt&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;ep)&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
	h[u]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;p;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addedge&lt;/span&gt;(ele u,ele v,ele r,ele c){
	addedge1(u,v,r,c); addedge1(v,u,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;c);
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;spfa&lt;/span&gt;(ele s,ele t){
	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; queue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Q;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) d[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;INF;
	d[s]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
	Q.push(s);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;Q.empty()){
		ele k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Q.front(); Q.pop();
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (edge &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;h[k]; j; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;nxt)
			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; d[k]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;d[j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;v]){
				d[j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;v]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;d[k]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;c;
				Q.push(j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;v);
			}
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; d[t]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;INF;
}
pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ele,ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; dfs(ele i,ele t,ele p){
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;p &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;t) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; make_pair(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,p);
	ele ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,ans1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
	vis[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;true;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (edge&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;amp;&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;cur[i]; j; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;nxt)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;vis[j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;v] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; d[i]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;d[j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;v]){
			pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ele,ele&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;dfs(j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;v,t,min(p,j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;r));
			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (tmp.se){
				ans&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp.fi; ans&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;tmp.se;
				ans1&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp.se;
				j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;r&lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt;tmp.se; j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;rev&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;r&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;tmp.se;
				p&lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt;tmp.se;
				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;p) &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
			}
			&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; d[j&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;v]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;INF;
		}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;make_pair&lt;/span&gt;(ans,ans1);
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; ele &lt;span style=&#34;color:#a6e22e&#34;&gt;mincost&lt;/span&gt;(ele s,ele t){
	ele ans&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (spfa(s,t)){
		memset(vis,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(vis));
		memcpy(cur,h,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(h));
		ans&lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt;dfs(s,t,INF).fi;
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
	scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d%d%d&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;n,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;m,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;K);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;j) g[i][j]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;INF;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (m&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;){
		ele u,v,w;
		scanf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d%d%d&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;u,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;v,&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;w);
		g[u][v]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;g[v][u]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;min(g[u][v],w);
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; k&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;k)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
			&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;j)
				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (max(i,j)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt;k)
					g[i][j]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;min(g[i][j],g[i][k]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;g[k][j]);
	ecnt&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ep; memset(h,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(h));
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;j) addedge(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,g[i][j]);
	addedge(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,K,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) addedge(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt;n; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) addedge(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
	printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,mincost(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://seraphim.rocks/posts/bzoj2324/ - </description>
        </item>
    
    
    
        <item>
        <title>雅礼2018年7月集训总结</title>
        <link>https://seraphim.rocks/posts/yali201807/</link>
        <pubDate>Sun, 01 Jul 2018 20:15:04 +0800</pubDate>
        
        <guid>https://seraphim.rocks/posts/yali201807/</guid>
        <description>蒟蒻的博客 https://seraphim.rocks/posts/yali201807/ -&lt;p&gt;&lt;!-- raw HTML omitted --&gt;NOI前的垂死挣扎.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;7-1&#34;&gt;7-1&lt;/h2&gt;
&lt;p&gt;考得还不错的样子，但是还有可以完善的地方.&lt;/p&gt;
&lt;h3 id=&#34;t1&#34;&gt;T1&lt;/h3&gt;
&lt;p&gt;想到了出题人想到的状压dp，然后别人想出来了一个&lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n^3)\)&lt;/span&gt;的dp. 其实我是看到了题目的&lt;span class=&#34;math inline&#34;&gt;\(n\le 24\)&lt;/span&gt;就去想状压的，如果数据范围大一点我应该也能想到？&lt;/p&gt;
&lt;h3 id=&#34;t2&#34;&gt;T2&lt;/h3&gt;
&lt;p&gt;被卡常卡成60分了，主要是因为方点的情况我强行把分治FFT的做法搬过来写出了8倍常数. 事实上比赛的时候我已经注意到了方点相当于是没有度数限制的，而用在圆点上的分治FFT本来就是为了处理度数限制的问题，所以完全没有必要照搬，可以直接用一个线性的dp解决方点的情况.&lt;/p&gt;
&lt;h3 id=&#34;t3&#34;&gt;T3&lt;/h3&gt;
&lt;p&gt;写完+检查完前两道题的时候已经过去4h了，写暴力又花了一些时间导致我没什么时间想这道题. 当时我已经想出了&lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n^3)\)&lt;/span&gt;的dp做法，其实再注意到一些细节就可以优化到&lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(n)\)&lt;/span&gt;，但是剩下的时间连打完我想到的那个dp都很勉强. 说到底还是我思维比较迟缓，并且码力太过底下，前面debug了太长的时间，还是要多做点题.&lt;/p&gt;
&lt;h2 id=&#34;7-2&#34;&gt;7-2&lt;/h2&gt;
&lt;p&gt;区分度极低+极度劝退，rk8后面就是rk29. &lt;!-- raw HTML omitted --&gt;很荣幸能够挤进前10.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;t1-1&#34;&gt;T1&lt;/h3&gt;
&lt;p&gt;挺不错的一道题，链剖的做法也没有那么容易想到，不过想到了的话打起来非常舒服.&lt;/p&gt;
&lt;h3 id=&#34;t2-1&#34;&gt;T2&lt;/h3&gt;
&lt;p&gt;没怎么卡过空间，各种会分块会主席树但是MLE……&lt;/p&gt;
&lt;p&gt;首先询问区间中有多少种数是经典的难以合并信息的问题，询问一个区间还有分块或者主席树的做法，询问多个区间的话，没什么好的想法，就只能bitset卡一卡了.&lt;/p&gt;
&lt;p&gt;用bitset的话第一个问题是想办法做到&lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(\frac{nm}{w})\)&lt;/span&gt;而不是&lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(\frac{nm\log n}{w})\)&lt;/span&gt;. 直接ST表的话会MLE. 如果可以离线，就能用莫队把每个询问区间的bitset预处理出来. 其实反正已经用了bitset这么暴力的东西了，不妨维护的时候也暴力一点，把整个区间分成&lt;span class=&#34;math inline&#34;&gt;\(w\)&lt;/span&gt;个块，预处理出&lt;span class=&#34;math inline&#34;&gt;\(w^2\)&lt;/span&gt;个块对之间的bitset，每个询问区间在整块的基础上加上&lt;span class=&#34;math inline&#34;&gt;\(\mathcal O(\frac{n}{w})\)&lt;/span&gt;个数. 这样子空间开不下，可以把预处理&lt;span class=&#34;math inline&#34;&gt;\(w^2\)&lt;/span&gt;个块对改为用ST表维护各个块，就能把空间卡进去了.&lt;/p&gt;
&lt;h3 id=&#34;t3-1&#34;&gt;T3&lt;/h3&gt;
&lt;p&gt;差分之后按位置模&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;分类然后计算交错和什么的都很容易想到，关键是判无解非常麻烦，在左右端点需要特殊处理的情况下判无解更加麻烦，反正我在赛场上没想到优美的方法. 标解是利用hash，给每个模&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;的余数分配一个&lt;span class=&#34;math inline&#34;&gt;\([0,2^{64})\)&lt;/span&gt;之间的随机权值，那么计算询问区间中的&lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;的位置的异或和再进行判断就可以了. 要注意求多类位置分别的前缀交错和的和写法比较特殊，要让&lt;span class=&#34;math inline&#34;&gt;\(f _i\)&lt;/span&gt;表示让最后一个位置的权值为&lt;span class=&#34;math inline&#34;&gt;\(+1\)&lt;/span&gt;时的前缀交错和，这样区间中每类位置均出现偶数次的时候，就能拿两个前缀和做个差得到区间交错和了.&lt;/p&gt;
&lt;h2 id=&#34;7-3&#34;&gt;7-3&lt;/h2&gt;
&lt;p&gt;似乎基本都听过一遍？&lt;/p&gt;
&lt;h2 id=&#34;7-4&#34;&gt;7-4&lt;/h2&gt;
&lt;p&gt;除去std还有11个人ak&lt;!-- raw HTML omitted --&gt;，我是第12名&lt;!-- raw HTML omitted --&gt;. 后来可能还重测了几个丢了程序的人.&lt;/p&gt;
&lt;h3 id=&#34;t1-2&#34;&gt;T1&lt;/h3&gt;
&lt;p&gt;我的做法是想象高维空间，一个&lt;span class=&#34;math inline&#34;&gt;\(n+1\)&lt;/span&gt;维的基础图形实际上就是由&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;维的在第&lt;span class=&#34;math inline&#34;&gt;\(n+1\)&lt;/span&gt;维上平移得到的. 那么平移前后，每一维成分的数量首先是翻了一倍，另外平移前和平移后对应的&lt;span class=&#34;math inline&#34;&gt;\(j-1\)&lt;/span&gt;维的成分构成了一个&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;维的成分. 以二维到三维为例，一个正方形向上平移，得到了&lt;span class=&#34;math inline&#34;&gt;\(8\)&lt;/span&gt;个点和&lt;span class=&#34;math inline&#34;&gt;\(8\)&lt;/span&gt;条边，设平移前正方形为&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;，平移后正方形为&lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;，那么&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(B\)&lt;/span&gt;的每对对应点形成一条新的边，每对对应边形成一个新的面. 设&lt;span class=&#34;math inline&#34;&gt;\(f _{i,j}\)&lt;/span&gt;为&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;维基础图形中&lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;维的个数，即有&lt;span class=&#34;math inline&#34;&gt;\(f _{i,j}=2f _{i-1,j}+f _{i-1,j-1}\)&lt;/span&gt;，记&lt;span class=&#34;math inline&#34;&gt;\(F _i(z)=\sum f _{i,j}z^j\)&lt;/span&gt;，即有&lt;span class=&#34;math inline&#34;&gt;\(F _{i+1}(z)=(2+z)F _i(z)\)&lt;/span&gt;即&lt;span class=&#34;math inline&#34;&gt;\(F _n(z)=(2+z)^n\)&lt;/span&gt;，那么&lt;span class=&#34;math inline&#34;&gt;\(f _{n,m}=2^{n-m}\binom{n}{m}\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3 id=&#34;t2-2&#34;&gt;T2&lt;/h3&gt;
&lt;p&gt;跟以前见过的一道dp题比较像. 考虑从小到大决策每个元素，它的贡献依赖于前面的元素的决策，但是这个不方便表示为状态. 假设当前要加入的元素为&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;,可以把前面的元素分成跟&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;加在一起无贡献和有贡献的两部分，有贡献的部分只需要保存两边的数量就可以了，而无贡献的部分随着&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;的增大只会不断减少，所以我们可以先不决策无贡献的部分，当其中的元素变成有贡献的时候再进行决策，到最后都还是无贡献的那一部分放在哪边都不影响答案，所以最后乘一个&lt;span class=&#34;math inline&#34;&gt;\(2^\textrm{cnt}\)&lt;/span&gt;即可.&lt;/p&gt;
&lt;h3 id=&#34;t3-2&#34;&gt;T3&lt;/h3&gt;
&lt;p&gt;居然没想出来真是丢人. 我想到了容斥而且会做&lt;span class=&#34;math inline&#34;&gt;\(k=0\)&lt;/span&gt;居然还做不出来，可能是因为我总是想着一步把式子推到位，而没有把一些关键的量记为一个符号来简化思考.&lt;/p&gt;
&lt;p&gt;显然这道题就是要求极长同色子段恰有&lt;span class=&#34;math inline&#34;&gt;\(n-k\)&lt;/span&gt;个的方案数，用指数生成函数很容易算出段数不超过&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;的元次&lt;span class=&#34;math inline&#34;&gt;\(f _i\)&lt;/span&gt;. 其实这个时候就可以凑容斥系数了. 考虑一个实际有&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;段的方案，它只对&lt;span class=&#34;math inline&#34;&gt;\(j\ge i\)&lt;/span&gt;的&lt;span class=&#34;math inline&#34;&gt;\(f _j\)&lt;/span&gt;有贡献，且贡献的系数为&lt;span class=&#34;math inline&#34;&gt;\(\binom{n-i}{j-i}\)&lt;/span&gt;. 这是因为有&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;段相当于切了&lt;span class=&#34;math inline&#34;&gt;\(i-1\)&lt;/span&gt;刀，还有&lt;span class=&#34;math inline&#34;&gt;\(n-i\)&lt;/span&gt;个位置可以切，为了被算进&lt;span class=&#34;math inline&#34;&gt;\(f _j\)&lt;/span&gt;里面，还需要切&lt;span class=&#34;math inline&#34;&gt;\(j-i\)&lt;/span&gt;刀，所以共&lt;span class=&#34;math inline&#34;&gt;\(\binom{n-i}{j-i}\)&lt;/span&gt;种切法. 于是我们可以列出式子&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
化得好看一些

$$\sum _{p=0}^{n-i}c _{i+p}\binom{n-i}{p}=[k=n-i]$$

右边这个东西如果利用$[n=0]=\sum (-1)^i\binom{n}{i}$来做，反正我不会. 注意到$i\le n-k$（否则不可能有贡献，一般不会去考虑），可以启发我们展开$(z+1-1)^{n-i}$，得到

$$[z^k] (z+1-1)^{n-i}=\sum 1^p(-1)^{n-i-k-p}\frac{(n-i)!}{k!p!(n-i-k-p)!}$$

于是有

$$c _{i+p}=\frac{(-1)^{n-i-k-p}(n-i-p)!}{k!(n-i-k-p)!}$$

也就是$c _j=(-1)^{n-k-j}\binom{n-j}{k}$.

如果不想凑系数的话，也可以考虑求一个$g _i$表示恰好有$i$段的方案数. 注意到$f _i=\sum _{j\le i}g _j\binom{n-j}{i-j}$，强行反演其实就相当于上面的凑系数，或者你也可以写成$(n-i)!g _i=(n-i)!f _i-\sum _{j\lt i}(n-j)!g _j\cdot\frac{1}{(i-j)!}$，用多项式求逆的套路让$F(z)=\sum(n-i)!f _iz^i,G(z)=\sum(n-i)!g _iz^i$，就有$G(z)=F(z)-(e^z-1)G(z)$，即$G(z)=F(z)e^{-z}$.

感觉这是一道挺不错的计数题，这里面包含的几个新套路，一个是展开$(z+1-1)^{n-i}$，一个是$\binom{n-i}{j-i}$这个系数，都要记下来.

## 7-5

### T1

题目保证给定的点都在凸包上，所以询问区间中的点一定都在这些点的凸包上，也就是说只需要计算$\sum _{i=0}^{L-1}P _i\times P _{i+1}(P _L=P _0)$，其中$L$为询问区间的长度$P _0,P _1,\ldots,P _{L-1}$为询问区间中的点按照极角排序之后的结果.

那么$\mathcal O(n\sqrt{n}\log n)$的莫队就是显然的了. 想办法继续优化，注意到插入是$\mathcal O(\log n)$的，但删除可以做到$\mathcal O(1)$，可以用删除的撤销来代替插入. 具体来讲，把询问排序的时候，右端点从小到大改为从大到小，设当前询问区间的左端点所在块的左端点为$l _0$，维护$[l _0,n)$的凸包，每次询问的时候移动端点就只需要删除了，询问结束后恢复左端点. 如果左端点所在的块变化了，就恢复右端点，然后把左边的块删掉（此次不用恢复）. 只有插入的莫队思路略有不同，挺好想的就不讲了.

只有插入或者只有删除的莫队算是个以前没见过的技巧吧，要记下来.

### T2

可以用各种方法花式AC，稍微记录一下感觉比较有意思的.

这一个是我用的方法，答案保证严格大于$\frac{n}{2}$，所以中位数一定在答案里面，第一次输入把所有的数按照高$16$位分类，那么答案只可能在最中间的三类里面，第二次输入的时候把中间三类的数的低$16$位存在$3$个桶里，然后暴力就可以了. 

另外有一个挺有意思的随机化的做法，因为答案超过一般，随机选择$20$个位置，那么有很大概率至少选到了一个在答案里面的数，第二次读入的时候分别钦定这$20$个数在答案里，分别算出答案取最优.

### T3

这个题的构造也不知道是怎么想出来的，非构造解法晚点再研究吧.

从$m=2$入手，定义$g _0=g _1=g _2=1,g _n=g _{n-1}+g _{n-2}(n\ge 3)$，那么&lt;del&gt;神仙&lt;/del&gt;具有敏锐洞察力的选手就可以观察到如果$g _n=\sum _{i=1}^kg _{a _i}$，这里$a _1\gt a _2\gt\cdots\gt a _k\ge 2$（容易证明一定有这样的一个划分），那么$f(n)=\sum _{i=1}^kg _{a _i-1}$.

为什么是这样呢？首先把题目里面的式子移项，得到$f(n)+f _m(n-1)=n$，又有

$$\begin{aligned}n&amp;=\sum _{i=1}^kg _{a _i}\\\\f(n)&amp;=\sum _{i=1}^kg _{a _i-1}\\\\f _2(n)&amp;=\sum _{i=1}^kg _{a _i-2}\end{aligned}$$

后面两个式子加起来跟前一个比较，发现如果是$f(n)+f _m(n)=n$，似乎就有$g _n=g _{n-1}+g _{n-2}$了. 但是这里是$n-1$.

注意到$n-1$的分拆里面，前$k-1$个数跟$n$的分拆肯定是一样的，因而前$k-1$项仍满足上式，我们讨论$g _{a _k}$.

- $g _{a _k}=1$，此时$n-1$的分拆没有最后一项，因为$1=1+0$，最后一项仍满足上式.

- $g _{a _k}&gt;1$，此时相当于$f _2(n-1)$的分拆最后一项变成了$f _2(g _{a _k}-1)$的分拆形式，由题目我们知道它等于$g _{a _k}-f(g _{a _k})=g _{a _k}-g _{a _k-1}=g _{a _k-2}$，即最后一项仍满足上式.

规定$g _0=1$而不是$g _0=0$是因为要考虑$f(1)$.

对于一般的情况，定义$g _0=g _1=\cdots=g _m=1,g _n=g _{n-1}+g _{n-m}(n\gt m)$即可.

其实这个时候你会发现如果那一项是$f _m(n)$的话反而可能会出一些问题.

## 7-7

网络流题好像有一个比较常见的思路是，当每个东西有多个决策的时候，先全部假定一下，然后再用网络流去调整.

## 7-8

挂了挂了……

### T1

最小树形图的朱刘算法.

也不知道出题人是怎么想的……

### T2

我的做法似乎比std更nb一些？反正std4k跑5s，我的代码2.4k跑0.5s.

定义每个软件包开始安装的时间为$S _i$，实际安装花费的时间为$a _i$，最后答案为$T$. 那么首先有$\forall(i,j)\in E,S _j-S _i\ge a _i$. 总花费不超过$w$，可以表示成$\sum c _i(t _i-a _i)\le w$. 由题显然有$0\le a _i\le t _i$. 最后答案其实相当于是对$S _i+a _i$取$\max$，可以加入$n$个约束$T\ge S _i+a _i$，然后就是要在满足上面所有这些约束的前提下最小化$T$，直接上单纯形就可以了.

考试的时候我想到了基本相同的思路，但是没有往线性规划的方向去想，强行建了一个点数极多的图，还不知道哪里写错了一点东西，最后没拿到分. 其实网络流和线性规划很多地方是有联系的，以后想网络流建图类的问题时，不妨结合线性规划一起想，毕竟有的时候网络流更简单一些，有的时候线性规划更简单一些.

出题人列出的线性规划式子要考虑每一条路径，所以约束个数可能达到指数级，要先对偶再转化成网络流来做. 我列出的式子和出题人不太一样，只有$\mathcal O(n)$个变量，$O(n+m)$个约束，直接跑单纯形就非常快了.

不过现在还遗留了一个小问题，无论是我的做法还是出题人的做法，似乎都不能保证减少之后的安装时间是整数. 我想了一想，觉得好像可以证明至多只有一个$a _i$不是整数，所以最后只需要把答案向上取整就可以了，当然有单纯形的话需要考虑一下精度问题，先减去一个eps再向上取整. 出题人的做法要二分答案，所以只需要把二分的精度限制在整数就可以了.

### T3

毒瘤！

## 7-9

今天的题目是上交的，长得根本不像NOI模拟赛……

题目比较水，而我第二题被卡常卡掉了52分，最后只能排rk29.

### T1

水题.

不过倒是学到了一个东西：线性预处理$1,2,\ldots,n$逆元的`(MOD-MOD/i)*inv[MOD%i]`的做法虽然看上去很炫酷，但是里面用了除法，实际上常数很大，需要卡常的时候得注意一下.

### T2

第一反应是世界树那道题，我以前因为太难码放弃了，这回在考场上硬生生码了200+行代码写了出来，可是A掉了bzoj的世界树那题，模拟赛里面的这道题却被卡常卡成48分了.

事实上这道题是世界树那道题的简化版，有一个常数~~应该~~更小的做法. 这道题目只需要询问$a _1$占领了哪些点，所以可以对每个$j\in[2,k]$，求出$a _1$与$a _j$的中点$m _j$，那么$m _j$靠$a _j$的那一边肯定不会被$a _1$占领，这对应着树上的一棵子树或除了一棵子树以外的其它部分，而对每个$a _j$去掉那些部分之后，剩下的就是$a _1$可以占领的点了. 这样只需要用一棵线段树在dfs序上做区间修改，应该比虚树的做法好写很多.



### T3

&gt; 题目：为了锻炼你的水平，建议使用在线算法.
&gt;
&gt; 我：我没有水平，我离线！

于是我就写了一个按时间分治水了过去. ~~其实码力低下的我还是因为一个弱智的bug耽搁了很久.~~

考虑在线算法，如果只在一段加和删，那显然可以直接做背包，删除可以看做是插入的撤销，直接再插入的时候做一个之前时刻的备份就可以了. 如果在两端加和删，可以在两端分别用一个背包来维护，每次查询相当于是要把两个背包合并起来，直接合并是$\mathcal O(\text{MOD}^2)$的，但是因为只需要合并两个背包而不是多个，也只需要求合并后一段区间里面的最值，而不是背包的完整信息，可以枚举其中一个背包中的值，然后在另一个背包里做区间查询，复杂度降到$\mathcal O(\text{MOD}\log\text{MOD})$.

加入删除之后会出现一个问题，就是一边背包被删空了会开始删另一个背包的另一端. 一个显然的思路是暴力把另一个背包栈的开口反向，但这样的话如果左边删一个右边删一个循环的话复杂度就不对了. 解决方法也很简单，这种时候把另一个背包的一半元素分离出来，反向，另一半保持不变，均摊分析一下会发现复杂度是$\mathcal O(\text{MOD}\log m)$的.

最后，这个在线算法的复杂度为$\mathcal O(m\text{MOD}(\log\text{MOD}+\log m))$.

## 7-10

本来应该200分rk3的……一定要吸取教训. 我T2打了一个$\mathcal O(m\sqrt{L}\log L)$的做法，本来可以拿90分，但是数组开得比较大MLE了，但事实上是跑不满的，这也就导致用任务管理器之类的东西看内存消耗看的也远小于开的数组的大小. 可是很多评测软件看的是你开了多少而不是用了多少，所以以后还是尽量要手算空间，如果觉得跑不满又开不下，还是用vector或者别的一些方法动态开空间吧. 这个一定要记住，今天这种情况真的非常可惜.

### T2

这种题对于$\gt\sqrt{L}$的情况要善于勇敢地暴力，做这道题的时候我考虑$\gt\sqrt{L}$的情况考虑了很久，最后发现单独处理这些串的时候，每个串就算是暴力枚举前缀，暴力与前面的比对，复杂度都是对的.

还是写一下做法吧怕自己忘了. 记$L=\sum|s _i|$，对于每个询问考虑$|S|\le\sqrt{L}$和$|S|\gt\sqrt{L}$两种情况. 

对于第一种情况，各种套路想一遍发现按右端点排序来做的套路比较靠谱，设$f _{i,j}$代表以$i$为右端点，要使得存在长度为$j$的前缀有贡献，左端点最右的位置，这个可以根据$f _{i-1,j}$和$i$这个串长度为$j$的前缀的贡献来计算. 要计算后者，可以把所有串长度不超过$\sqrt{L}$的前缀取出来，记录一个$\text{pos} _s$表示以$s$为前缀的串的位置列表，然后在上面查就可以了. 事实上因为$f$可以存下来，这一步不需要离线.

对于第二种情况，有贡献的串至多$\sqrt{L}$个，把询问按照包含这些串的区间分类，离线下来，记第$i$个询问包含这些串的区间是$[u _i,v _i]$. 以$u$为第一关键字，$v$为第二关键字排序，这样固定$u$之后$v$增大就相当于在后面暴力加串. 加串的话，可以暴力枚举前缀，然后暴力扫一遍前面的串来统计这个前缀的出现次数，判断它有没有贡献（要事先预处理长度$\gt\sqrt{L}$的串两两之间的lcp，这个也可以暴力预处理）. 这样加串的总复杂度不超过$\sum\sqrt{L}|S|=L\sqrt{L}$，同样暴力预处理lcp的复杂度也不超过这个.

按照以上的方法就可以求出有贡献的长度的集合，要统计答案，支持加一个长度和删一个长度，随便用个数据结构就可以维护了.

但这样是$\mathcal O(m\sqrt{L}\log L)$的，跑最后一个点很悬. 如果要继续优化的话，注意到只有插入会带$\log$，删除不会，使用熟悉的套路，把插入看成删除的撤销即可. 具体来讲，$\le\sqrt{L}$的部分全程删除和全程插入是一样的，因为原来算法是把有贡献的插入，改成一开始全部插入好，利用$f$数组找出没贡献的删掉就行了，最后再恢复成删掉之前的样子来处理下一个询问. 至于$\gt\sqrt{L}$的部分，改成$u$从小到大，$v$从大到小，就变成全程都是删除了.

再讲讲我不优化算法是怎么卡常卡进去的. 首先维护的数据结构不要用set或者线段树这么大常数的东西，用zkw，顺手把删除写成$\mathcal O(1)$的，再加个读入优化，这个时候已经从12s优化到4.9s了，放到lemon上面跑的时候因为玄学原因变快了一些就过了.

### T3

先坑着.

## 7-12

居然rk1了？

### T1

先坑着.

### T2

首先一个很显然的思路是链上修改单点查询转化为单点修改子树查询，然后就可以做树上的启发式合并，来得到每个点对应的trie了. 事实上trie的合并可以像线段树合并那样做，就可以少一个$\log$. 求期望的路径长度的话，每个点记一个$f _i$表示从$i$出发的期望步数，它的转移跟父亲有关，有一个经典的技巧是把$f _i$表示成$a _i+b _if _{\text{fa} _i}$的形式，这样就可以不用高斯消元，第一遍dfs先把$a,b$求出来，第二遍dfs把$f$求出来. 不过此题要算的是所有$f$的和，而且还要动态维护，所以再记一个$s _i$表示以$i$为根的子树的$f$的和，发现$s _i$也可以表示为$c _i+d _if _{\text{fa} _i}$的形式. $a,b,c,d$都可以很方便地在trie上动态维护，这样就能快速地求出答案了.

评测的时候最后两个点好像爆栈了？但是noi应该会开无限栈的吧.

### T3

一开始的时候觉得多项式开根常数太大了，就写了个分治来求$f$，结果$b _i\le 10^5$的点跑了6.7s. 麦老大说开根常数再大也不会比$\mathcal O(n\log^2n)$的分治慢. 膜拜10min打完多项式板子的dalao……

假设我们已经把$f _i$求出来了，考虑一个简单一点的问题，已经知道$x,x^2,x^3,\ldots,x^n$，怎么求出$x^{n+1}$. 这个显然用脚都能求出来. 但是现在它是一堆东西加起来，所以应该使用线性的方法，换句话说可以考虑把$x^{n+1}$表示成$x,x^2,x^3,\ldots,x^n$的线性组合. 回忆一下在哪里干过类似的事，可以联想到求常系数线性递推的时候，把$M^n$表示成$I,M,M^2,\ldots,M^{n-1}$的线性组合. 当时是利用了$M$的化零多项式，容易想到现在也要构造一个多项式$p(t)$使得$f _{b _1},f _{b _2},\ldots,f _{b _n}$是它的根，显然$p(t)=\prod(t-f _{b _i})$，这个用分治fft来求就可以了.

下面考虑一下如何更高效地求出$f _i$. 我们知道$f _i$的生成函数$F(z)=\frac{1-\sqrt{1-4z^2-16z^3-16z^4}}{2z(1+2z)}$，这是一个多项式开根的经典题目，但是这里它有一个特殊性质，就是这些式子的次数都很低，不妨把它写成$\frac{A(z)-\sqrt{C(z)}}{B(z)}$的形式，先考虑怎么算$D(z)/B(z)=X(z)$，移项得到$B(z)X(z)=D(z)$，代入$B(z)=2z(1+2z)$，比较$z^n$的系数，得到$d _n=2x _{n-1}+4x _{n-2}$，即$x _n=\frac{d _{n+1}-4x _{n-1}}{2}$，这样就可以线性递推了. 接下来考虑怎么计算$\sqrt{C(z)}=Y(z)$，求导得到$Y^\prime(z)=\frac{C^\prime(z)Y(z)}{2C(z)}$，即$2C(z)Y^\prime(z)=C^\prime(z)Y(z)$. 代入再比较$z^n$的系数，得到$2((n+1)h _{n+1}-4(n-1)h _{n-1}-16(n-2)h _{n-2}-16(n-3)h _{n-3})=-8h _{n-1}-48h _{n-2}-64h _{n-3}$，把下标平移一下再化简，得到$nh _n=(4n-12)h _{n-2}+(16n-72)h _{n-3}+(16n-96)h _{n-4}$. 这样就可以线性递推了.

感觉有的时候求个导可以得到一些奇奇怪怪的但是有用的东西.\]&lt;/span&gt;&lt;/p&gt;- https://seraphim.rocks/posts/yali201807/ - </description>
        </item>
    
    
  </channel>
</rss> 