[{"categories":null,"contents":"我存在levelDB里面的数据丢了好几次，最近研究了一下，虽然不确定具体的原理，但大概知道怎么避免类似情况了。\n经过观察可以发现，就算不对数据库进行修改，仅仅是查询，文件也会发生变化。而我丢失数据，均发生在使用git切换分支，再切换回来的时候。我推测这之中某个时候，因为读数据发生了文件变动，然后切换分支又撤销了一部分文件变动，导致了数据库的损坏。\n暂时不清楚损坏过程，但是要记住，不要把数据库放到git repo里面！\n有些数据丢了是真的心疼，还好从某个备份里找回来了不少。\n","permalink":"https://seraphim.rocks/posts/leveldb-and-git-md/","tags":["stuffs"],"title":"LevelDB数据丢失问题"},{"categories":null,"contents":"使用AnyTypescript已经有一段时间了，这期间踩了不少坑，也发现了一些骚操作。这里简单记录一下。\nCommonJS与ES Module兼容的问题 由于各种原因，CommonJS的模块化方式与ES Module的模块化方式之间并不能很容易地一一对应起来。ES Module中有default export的概念，如果在0.js中写\nexport default A 那么就可以在1.js里面使用\nimport anyNameYouLike from \u0026#39;./0\u0026#39; 来加载。但同时，一个模块在拥有default export的同时，也允许拥有别的export，这样一来，default export就得被编译成\nmodule.exports.default=A 而不是\nmodule.exports=A 但是问题在于，CommonJS的模块只导出一个对象时，往往会采用后一种方式，而ES Module又不能实现后一种方式，这就会导致许多混乱。\nTypescript的编译器提供了一个编译选项--esModuleInterop，加上它就能解决这个问题。这样就可以在自己的代码里统一使用default export和default import了。\n前端项目Code Splitting及磁盘空间节省 因为种种原因我不想用webpack，而我还不能使rollup正常工作，所以我用的bundler一直还是browserify。于是我必须手动进行Code Splitting。\n为了使用类型推断等功能带来的便利，使用前端库的时候，同样需要将其安装到本地并import。但另一方面，为了减小bundle体积，优化首屏体验，用到的很多库其实应该从cdn加载。为了兼顾这两点，可以使用一个browserify的transform：browserify-shim。以React这个包为例，在package.json里加上如下配置：\n{ \u0026#34;browserify\u0026#34;:{ \u0026#34;transform\u0026#34;:[ \u0026#34;browserify-shim\u0026#34; ] }, \u0026#34;browserify-shim\u0026#34;:{ \u0026#34;react\u0026#34;:\u0026#34;global:React\u0026#34; } } 注意第一个react是包名，第二个React是由cdn导入的库提供的全局变量名。\n那这个跟磁盘空间节省又有什么关系呢？它之所以能节省磁盘空间，是因为这么做了之后，本地不需要安装react，只需要安装@types/react，就可以import然后正常使用了。\n顺便提一下，可以把所有脚本加上defer然后放到\u0026lt;head\u0026gt;里面，这样脚本会异步并行加载，并在dom渲染完成后，按照\u0026lt;script\u0026gt;标签的顺序执行。\n","permalink":"https://seraphim.rocks/posts/ts-notes/","tags":null,"title":"Typescript使用笔记"},{"categories":null,"contents":"前段时间开始试着用typescript，感觉有一个很明显的问题是，习惯了脚本语言之后，我不太有耐性等待一两秒的编译。最近折腾了各种方法，一开始我想禁用掉typescript的类型检查来提升编译速度（反正编辑器里就会进行检查），结果发现tsc并没有这个编译选项，倒是ts-node有一个-T选项可以做到这点。其实一个更好的解决方案可能是使用增量编译。\ntsc本身就能实现增量编译的效果，运行\ntsc --watch src/*.ts --outDir dist --sourceMap 就能启动一个服务，在检测到文件修改的时候，进行增量编译。一般来讲，增量编译会比重新编译整个项目快得多。这个方法在用typescript写后端的时候应该够用了。\n但是这个方法不太适合写前端。如果再用browserify这样的bundle工具进行打包的话，得到的source map对应的是tsc编译之后的结果，不便于前端的调试。事实上，browserify提供了一个叫做watchify的插件，watchify的用法跟browserify基本一样，区别在于，watchify必须用-o指定输出文件，比如：\nwatchify -t tsify --debug -v -o bundle.js src/index.ts UPD： 写之前的内容的时候，电脑是长期接着电的，刚刚发现不接电的话watchify会比tsc --watch慢。折腾了一晚上又发现了一个方法。有一个browserify的transform叫做sourceify，简单地理解的话，它可以递归地读取source map，然后inline到bundle里面，这样就可以先用tsc --watch编译，然后browserify打包了。但是有于sourceify的一些feature，debug的时候要在web服务器上把/source映射到根目录。\n另外还有几个细节：一是tsc编译jsx还是会很慢UPD：不会，另外直接tsc -w就可以了。\nUPD： 不知道为什么，把一条import语句去掉的时候编译可能会比较久。\n","permalink":"https://seraphim.rocks/posts/watch/","tags":["stuffs"],"title":"使用增量编译加快typescript项目编译"},{"categories":null,"contents":"Windows Terminal终于支持显示中文/输入中文了，真是大快人心。\n我平时在Windows Terminal里面使用git-bash，输入中文一直会遇到一些问题，今天终于把问题折腾没了。\n具体来讲，就是输入中文以后，要多次退格才能删除一个中文字符，而且即使删除了，仍然会有不可见字符。但是这个问题在我使用git-bash自带的mintty的时候又会神秘解决。\n这是因为utf-8是不定长的编码，汉字占三个字节，但git-bash“认为”我使用的是定长的编码，汉字占两个字节。这样一来，按了两次退格之后，汉字就不显示了，但实际上还有一个字节没有被删除。\n既然在mintty中问题被解决，说明mintty中应该做了某种配置，让git-bash默认使用utf-8。我上网查了一下，发现可以在~/.bashrc里面加上两行来解决这个问题：\nexport LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 我怀疑只需要其中一行就能起作用，但我懒得实验了。\n","permalink":"https://seraphim.rocks/posts/gitbashutf8/","tags":["stuffs"],"title":"在git-bash下输入中文"},{"categories":null,"contents":"早就听说微软雅黑存在版权问题，而思源字体非常优越，但是我之前折腾了半天一直装不上就很尴尬了。\n首先思源字体可以从github上面下载。按照网上大多数人的说法，安装字体后，在xelatex里面使用如下代码就能使用思源字体了。然而并不能。\n\\usepackage{xeCJK} \\usepackage{fontspec} \\setCJKmainfont{Source Han Serif} 今天我终于弄清楚了为什么：安装字体的时候要选择为所有用户安装。这也太惨了。\n现在还是有一点小问题，latex里面的思源字体跟别的地方显示的稍有不同，比如“浅”字有三横什么的。 改成\\setCJKmainfont{Source Han Serif SC}就可以了。\n","permalink":"https://seraphim.rocks/posts/sourcehan/","tags":["stuffs"],"title":"如何在xelatex中使用思源字体"},{"categories":null,"contents":"随便发点东西就当除草。\n这个东西调了我一整晚……心态爆炸\n简单来讲就是，使用nodejs stream的pipe的时候，它可能会在某些地方进行编码转换，有些地方你可以手动指定为只传输二进制，但有的地方似乎不行 (也有可能是我还没找到)。\n总之如果没弄清楚原因，以后用pipe尽量只传输文本数据，要传二进制的话尽量用系统自带的管道。\n UPD:\n今天又研究了一下，如果用spawn而不是exec的话，没有这个问题，可能是因为exec会自动启动一个shell，然后shell里面的编码出了问题。\n另外要注意一下，encoding:'binary'并不是真的binary，而是一种叫latin1的编码，传二进制数据的时候什么都不要设置就好了。不过这么做的话，版本不能太旧，否则可能会出问题。\n","permalink":"https://seraphim.rocks/posts/pipe/","tags":["stuffs"],"title":"使用nodejs的pipe遇到的一点小问题"},{"categories":null,"contents":"go get下载第三方包的时候大多数情况要从github上面pull，有的时候还要从golang.org之类的地方下载源码. 由于众所周知的原因git clone速度极慢，golang.org根本不能访问，所以golang下载第三方包的时候总是极其麻烦. 最近写了个程序解决这个问题.\n讲一下大概的思路.\n我发现git clone和github上面的download zip是从不同的地方下载的，而download zip比git clone快很多，所以可以写个程序自动download zip，解压到安装第三方包的文件夹下，再编译.\n至于golang.org，它在github.com/golang上面有镜像，至于其它一些网站也多半在github上面有镜像，程序里面获取下载链接的时候额外处理一下就可以了.\n大概用法：把go get换成gogetpkg -p就行，如果第三方包的代码已经下载下来并放到正确位置，只需要安装的话，可以加上-nd，这样就会不下载直接安装.\n举几个栗子：\ngogetpkg -p github.com/jwhj/gogetpkg # 我装我自己 gogetpkg -p golang.org/x/tools/imports # 装package里面的package也是可以的 gogetpkg -p golang.org/x/tools/playground -nd # 刚刚已经把整个golang.org/x/tools下载下来了 # 就不用再下载一次了 你会发现它并不能处理依赖，你需要手动处理……\n项目地址：https://github.com/jwhj/gogetpkg\n","permalink":"https://seraphim.rocks/posts/gogetpkg/","tags":["stuffs"],"title":"解决go get下载缓慢的问题"},{"categories":null,"contents":"bzoj上的题面真是残缺不全……uoj上有完整的题面.\n退役久了脑子都不好用了，这么简单的东西推了半天……\n看到这种求和题很自然地就会想到拆成卷积的形式：\n\\[Q(f,n,x)=n!\\sum _{k=0}^n\\frac{f(k)x^k}{k!}\\cdot\\frac{(1-x)^{n-k}}{(n-k)!} \\]\n记\n\\[\\begin{aligned} g(z)\u0026=\\sum\\frac{f(k)x^k}{k!}z^k\\\\ h(z)\u0026=\\sum\\frac{(1-x)^k}{k!}z^k \\end{aligned} \\]\n那么答案就是\\(n![z^n]g(z)h(z)\\).\n很容易看出\\(h(z)=e^{(1-x)z}\\)，关键是怎么表示\\(g(z)\\).\n这里要用到一个结论：记\\(P _L(z)=\\sum\\left\\{\\begin{matrix}L\\\\k\\end{matrix}\\right\\}z^k\\)，那么有\n\\[e^zP _L(z)=\\sum _k\\frac{k^L}{k!}z^k \\]\n证明的话，对\\(L\\)归纳就可以了. 感觉这个结论在很多时候都挺有用的.\n设\\(f(x)=\\sum c _ix^i\\)，那么就有\n\\[\\begin{aligned} g(z)\u0026=\\sum _k\\left(\\frac{(xz)^k}{k!}\\sum _ic _ik^i\\right)\\\\ \u0026=\\sum _ic _i\\sum _k\\frac{(xz)^kk^i}{k!}\\\\ \u0026=\\sum _ic _ie^{xz}P _i(xz) \\end{aligned} \\]\n那么答案就是\\(n![z^n]e^z\\sum _{i=0}^mc _iP _i(xz)\\)\n记\\(t(z)=\\sum _{i=0}^mc _iP _i(xz)\\)，注意到\\(\\deg t=m\\)，所以如果我们能把\\(t(z)\\)求出来的话，剩下就只需要做一个长度为\\(m\\)的卷积了(而不是题目式子里长为\\(n\\)的卷积).\n为了求出\\(t(z)\\)，考虑到斯特林数没有什么太好的性质，我们需要给它乘回一个\\(e^{xz}\\). 我们知道\\([z^k]t(z)e^{xz}=\\frac{f(k)x^k}{k!}\\)，所以要求\\(t(z)\\)的话我们可以把\\(\\sum _k\\frac{f(k)x^k}{k!}z^k\\)和\\(e^{-xz}\\)的前\\(m+1\\)项做一个卷积.\n这道题，总的来说，这么一大通的变换，主要目的就是分离出一个长度为\\(\\mathcal O(m)\\)的多项式，这样一切就都好处理了.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; const ele maxn=1\u0026lt;\u0026lt;16|1; const ele MOD=998244353; const ele g=3; ele n,m,x,f[maxn],fac[maxn],ifac[maxn],a[maxn],b[maxn]; inline ele\u0026amp; add(ele\u0026amp;a,ele b){ a+=b; return a\u0026gt;=MOD?a-=MOD:a; } inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } inline void ntt(ele K,ele n,ele *y){ static ele f[maxn]; f[0]=0; for (int i=1; i\u0026lt;n; ++i){ f[i]=f[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1; if (i\u0026amp;1) f[i]+=n\u0026gt;\u0026gt;1; if (i\u0026lt;f[i]) swap(y[i],y[f[i]]); } for (int p=1; p\u0026lt;n; p\u0026lt;\u0026lt;=1){ ele o=pw(g,(MOD-1)/p/2); o=~K?o:pw(o,MOD-2); for (int i=0; i\u0026lt;n; i+=(p\u0026lt;\u0026lt;1)) for (int j=i,o1=1; j\u0026lt;i+p; ++j,o1=(ll)o1*o%MOD){ ele u=y[j],v=(ll)y[j+p]*o1%MOD; y[j]=y[j+p]=u; add(y[j],v); add(y[j+p],MOD-v); } } if (!~K){ ele invn=pw(n,MOD-2); for (int i=0; i\u0026lt;n; ++i) y[i]=(ll)y[i]*invn%MOD; } } int main(){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;x); for (int i=0; i\u0026lt;=m; ++i) scanf(\u0026#34;%d\u0026#34;,f+i); fac[0]=1; for (int i=1; i\u0026lt;=m; ++i) fac[i]=(ll)fac[i-1]*i%MOD; ifac[m]=pw(fac[m],MOD-2); for (int i=m-1; ~i; --i) ifac[i]=(ll)ifac[i+1]*(i+1)%MOD; ele tmp=1; while (tmp\u0026lt;=m+m) tmp\u0026lt;\u0026lt;=1; memset(a,0,sizeof(ele)*tmp); memset(b,0,sizeof(ele)*tmp); for (int i=0,p=1; i\u0026lt;=m; ++i,p=(ll)p*x%MOD){ a[i]=(ll)f[i]*p%MOD*ifac[i]%MOD; b[i]=(ll)p*ifac[i]%MOD; if (i\u0026amp;1) b[i]=MOD-b[i]; } ntt(1,tmp,a); ntt(1,tmp,b); for (int i=0; i\u0026lt;tmp; ++i) a[i]=(ll)a[i]*b[i]%MOD; ntt(-1,tmp,a); ele ans=0; for (int i=0,p=1; i\u0026lt;=m; p=(ll)p*(n-i)%MOD,++i) add(ans,(ll)a[i]*p%MOD); printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } ","permalink":"https://seraphim.rocks/posts/bzoj4734/","tags":["题解","bzoj","uoj","多项式"],"title":"'[whj什么都不会系列-2]bzoj4734\u0026uoj269题解'"},{"categories":null,"contents":"再厚颜无耻地放个小游戏.\n地址 https://jwhj.github.io/nsmo/\n源码放在 https://github.com/jwhj/nsmo\n跟arcsine比起来这个才像一个真的游戏.我感觉还挺好玩的.","permalink":"https://seraphim.rocks/posts/nsmo/","tags":["stuffs"],"title":"N Squared Minus One"},{"categories":null,"contents":"厚颜无耻地发一个自己写的小游戏.\n地址 http://jwhj.github.io/arcsine/ ，打开就能玩.\n源码放在 https://github.com/jwhj/arcsine ，写得很丑希望不要被嘲讽. 说得好像有人会看一样.\n游戏功能也许会在未来进一步完善. 毕竟我比较懒.\n","permalink":"https://seraphim.rocks/posts/arcsine/","tags":["stuffs"],"title":"Arcsine"},{"categories":null,"contents":"厚颜无耻地把自己的项目发上来.\n其实也没写什么东西，就是把reveal.js封装了一下. 这样就可以比较方便地用markdown直接写，也可以一条命令导出，方便在其他电脑上播放.\n暂时还没有写文档，也许会在有生之年补上.\n项目地址\n","permalink":"https://seraphim.rocks/posts/mdslide/","tags":["stuffs"],"title":"用markdown做slides"},{"categories":null,"contents":"退役了只有一直没怎么做题，感觉水平退步了不少，以前一些比较显然的思路现在可能都想不到了. 这样下去肯定是不行的，我尽量时不时做点水题写点题解恢复一点智商吧.\n题意 给定\\(n,m\\)，求有多少对\\((i,j)\\)满足\\(1\\le i\\le n,1\\le j\\le m\\)且\\(\\gcd(i,j)\\)为素数.\n共\\(T\\)组数据.\n\\(n\\le 10^7,T\\le 10^4\\)\n解 记\\(f(n,m)=\\sum _{i=1}^n\\sum _{j=1}^m[i\\perp j]\\)，显然答案就是\n\\[\\sum _{p\\text{ is prime}}f([n/p],[m/p]) \\]\n下面看\\(f\\)怎么算. 如果\\(n=m\\)，显然有\\(f(n,n)=\\sum _{i=1}^n\\varphi(n)\\)，预处理欧拉函数前缀和就可以做了.\n\\(n\\neq m\\)的时候一个显然的套路就是莫比乌斯反演：\n\\[\\begin{aligned} f(n,m)=\u0026\\sum _{i}\\sum _{j}\\sum _{d|\\gcd(i,j)}\\mu(d)\\\\ =\u0026\\sum _{d}\\mu(d) [n/d] [m/d] \\end{aligned} \\]\n用整除分块可以做到\\(\\mathcal O(\\sqrt{n})\\)的复杂度，从而每次询问是\\(\\mathcal O(n^{3/4})\\)， 但这还是太慢了.\n前面都是废话.\n\\(f\\)本身的计算已经没什么办法优化了，考虑代入\\(f([n/p],[m/p])\\)，得到\n\\[\\begin{aligned} \\sum _{p\\text{ is prime}}f([n/p],[m/p])=\u0026\\sum _{p\\text{ is prime}}\\sum\\mu(d) [n/(pd)] [m/(pd)]\\\\ =\u0026\\sum _{T}[n/T] [m/T]\\sum _{p|T,p\\text{ is prime}}\\mu(T/p) \\end{aligned} \\]\n记\\(g(T)=\\sum _{p|T,p\\text{ is prime}}\\mu(T/p)\\)，观察一下可以发现\\(g(n)\\)很有规律.\n记\\(s _1(n),s _2(n)\\)分别为\\(n\\)的不同素因数个数和歌素因数的指数和，那么当\\(s _1(n)=s _2(n)\\)时，\\(g(T)=-s _1(n)(-1)^{s _1(n)}\\)，当\\(s _1(n)+1=s _2(n)\\)时，\\(g(T)=(-1)^{s _1(n)}\\)，当\\(s _1(n)+2\\le s _2(n)\\)时，\\(g(T)=0\\).\n于是就可以很容易地处理\\(g(n)\\)的前缀和，进而\\(\\mathcal O(\\sqrt{n})\\)地处理每次询问.\n","permalink":"https://seraphim.rocks/posts/sbwhj-1/","tags":["题解","数论","sbwhj"],"title":"whj什么都不会系列-1"},{"categories":null,"contents":"AFO有段时间了，感觉自己什么都不会了，随便研究点东西证明我还活着……\n众所周知在long long乘long long模long long的时候，直接乘会溢出，所以要用一些技巧来处理. 一般的快速乘是\\(O(\\log x)\\)的，所以我们也可以叫它慢速乘. 事实上可以用一些技巧做到\\(O(1)\\)，实现真正的快速乘.\n首先我们知道\\(a\\)模\\(b\\)可以表示为\\(a-b\\lfloor a/b\\rfloor\\)，于是如果我们要计算\\(a\\times b\\)对\\(m\\)取模的结果，可以考虑计算\\(ab-m\\lfloor(a/m)*b\\rfloor\\). 写出下面的代码：\na%=MOD; b%=MOD; ele d=(long double)a/MOD*b+0.5; ele tmp=a*b-d*MOD; if (tmp\u0026lt;0) tmp+=MOD; 这里的a*b和d*MOD显然都会溢出，不过可以注意到，溢出只会使结果差\\(2^{64}\\)的整数倍，而模出来的结果显然不到\\(2^{64}\\)所以一定是对的.\n不过这里有一个小问题，为了防止炸精度，我们加了\\(0.5\\)来四舍五入，而不是向下取整，最后的结果可能会少一个\\(m\\)，所以最后要判断一下，如果tmp\u0026lt;0就要tmp+=MOD.\n另外的话如果\\(a\\ge m\\)或者\\(b\\ge m\\)可能会挂，所以一开始的时候要模一下.\n简化的代码：\ninline ele mul(ele a,ele b,ele MOD){ a%=MOD; b%=MOD; ele tmp=a*b-(ele)((long double)a/MOD*b+0.5)*MOD; return tmp\u0026lt;0?tmp+MOD:tmp; } ","permalink":"https://seraphim.rocks/posts/fastmul/","tags":["stuffs"],"title":"O(1)快速乘"},{"categories":null,"contents":"好久没写博客了，随便扔点东西上来除个草.\n其实也说不上是黑科技，就是自己平时折腾linux，折腾vim之类的东西的时候发现的一些小技巧罢了.\nesc键太远 平时用vim的时候经常要用到esc键，vim的设计理念本来是让手不用离开主键区，但是esc似乎就在主键区之外. 事实上vim刚被开发出来那会的键盘和现在是不一样的，那个时候esc还在主键区里面. 解决这个东西的方法有几个，我用的方法是把esc和caps lock调换一下，只需要在~/.xprofile里面加上这样一行代码（应该只对linux有效）：\nsetxkbmap -option caps:swapescape vim配置文件 set autoindent set tabstop=4 set shiftwidth=4 set noexpandtab let g:python_recommended_style=0 set nu set backspace=2 set mouse=a syntax on colorscheme desert map \u0026lt;space\u0026gt; : nnoremap j gj vnoremap j gj nnoremap k gk vnoremap k gk map JJ \u0026lt;esc\u0026gt; imap JJ \u0026lt;esc\u0026gt; map JK g$ map KJ g^ imap JK \u0026lt;esc\u0026gt;lg$a imap KJ \u0026lt;esc\u0026gt;hg^i map \u0026lt;f7\u0026gt; :%s/[\\u4E00-\\u9FCC]//gn\u0026lt;cr\u0026gt; function! P1() :%s/\\\\\\\\\\\\{/\\\\{/g :%s/\\\\\\\\\\\\}/\\\\}/g :%s/\\\\\\\\\\\\\\\\/\\\\\\\\/g endfunction function! P2() :%s/\\\\\\\\/\\\\\\\\\\\\\\\\/g :%s/\\\\{/\\\\\\\\\\\\{/g :%s/\\\\}/\\\\\\\\\\\\}/g endfunction call plug#begin('~/.vim/plugged') Plug 'godlygeek/tabular' Plug 'plasticboy/vim-markdown' Plug 'iamcco/markdown-preview.vim' Plug 'iamcco/mathjax-support-for-mkdp' Plug 'vim-scripts/fcitx.vim' Plug 'Shougo/neocomplete.vim' call plug#end() autocmd filetype markdown set shell=bash\\ -i let g:instant_markdown_autostart=0 \u0026quot; let g:instant_markdown_slow=1 let g:vim_markdown_folding_disabled=1 \u0026quot;Note: This option must be set in .vimrc(_vimrc). NOT IN .gvimrc(_gvimrc)! \u0026quot; Disable AutoComplPop. let g:acp_enableAtStartup = 0 \u0026quot; Use neocomplete. let g:neocomplete#enable_at_startup = 1 \u0026quot; Use smartcase. let g:neocomplete#enable_smart_case = 1 \u0026quot; Set minimum syntax keyword length. let g:neocomplete#sources#syntax#min_keyword_length = 3 \u0026quot; Define dictionary. let g:neocomplete#sources#dictionary#dictionaries = { \\ 'default' : '', \\ 'vimshell' : $HOME.'/.vimshell_hist', \\ 'scheme' : $HOME.'/.gosh_completions' \\ } \u0026quot; Define keyword. if !exists('g:neocomplete#keyword_patterns') let g:neocomplete#keyword_patterns = {} endif let g:neocomplete#keyword_patterns['default'] = '\\h\\w*' \u0026quot; Plugin key-mappings. inoremap \u0026lt;expr\u0026gt;\u0026lt;C-g\u0026gt; neocomplete#undo_completion() inoremap \u0026lt;expr\u0026gt;\u0026lt;C-l\u0026gt; neocomplete#complete_common_string() \u0026quot; Recommended key-mappings. \u0026quot; \u0026lt;CR\u0026gt;: close popup and save indent. inoremap \u0026lt;silent\u0026gt; \u0026lt;CR\u0026gt; \u0026lt;C-r\u0026gt;=\u0026lt;SID\u0026gt;my_cr_function()\u0026lt;CR\u0026gt; function! s:my_cr_function() return (pumvisible() ? \u0026quot;\\\u0026lt;C-y\u0026gt;\u0026quot; : \u0026quot;\u0026quot; ) . \u0026quot;\\\u0026lt;CR\u0026gt;\u0026quot; \u0026quot; For no inserting \u0026lt;CR\u0026gt; key. \u0026quot;return pumvisible() ? \u0026quot;\\\u0026lt;C-y\u0026gt;\u0026quot; : \u0026quot;\\\u0026lt;CR\u0026gt;\u0026quot; endfunction \u0026quot; \u0026lt;TAB\u0026gt;: completion. inoremap \u0026lt;expr\u0026gt;\u0026lt;TAB\u0026gt; pumvisible() ? \u0026quot;\\\u0026lt;C-n\u0026gt;\u0026quot; : \u0026quot;\\\u0026lt;TAB\u0026gt;\u0026quot; \u0026quot; \u0026lt;C-h\u0026gt;, \u0026lt;BS\u0026gt;: close popup and delete backword char. inoremap \u0026lt;expr\u0026gt;\u0026lt;C-h\u0026gt; neocomplete#smart_close_popup().\u0026quot;\\\u0026lt;C-h\u0026gt;\u0026quot; inoremap \u0026lt;expr\u0026gt;\u0026lt;BS\u0026gt; neocomplete#smart_close_popup().\u0026quot;\\\u0026lt;C-h\u0026gt;\u0026quot; \u0026quot; Close popup by \u0026lt;Space\u0026gt;. \u0026quot;inoremap \u0026lt;expr\u0026gt;\u0026lt;Space\u0026gt; pumvisible() ? \u0026quot;\\\u0026lt;C-y\u0026gt;\u0026quot; : \u0026quot;\\\u0026lt;Space\u0026gt;\u0026quot; \u0026quot; AutoComplPop like behavior. \u0026quot;let g:neocomplete#enable_auto_select = 1 \u0026quot; Shell like behavior(not recommended). \u0026quot;set completeopt+=longest \u0026quot;let g:neocomplete#enable_auto_select = 1 \u0026quot;let g:neocomplete#disable_auto_complete = 1 \u0026quot;inoremap \u0026lt;expr\u0026gt;\u0026lt;TAB\u0026gt; pumvisible() ? \u0026quot;\\\u0026lt;Down\u0026gt;\u0026quot; : \u0026quot;\\\u0026lt;C-x\u0026gt;\\\u0026lt;C-u\u0026gt;\u0026quot; \u0026quot; Enable omni completion. autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS autocmd FileType python setlocal omnifunc=pythoncomplete#Complete autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags \u0026quot; Enable heavy omni completion. if !exists('g:neocomplete#sources#omni#input_patterns') let g:neocomplete#sources#omni#input_patterns = {} endif \u0026quot;let g:neocomplete#sources#omni#input_patterns.php = '[^. \\t]-\u0026gt;\\h\\w*\\|\\h\\w*::' \u0026quot;let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\\t]\\%(\\.\\|-\u0026gt;\\)' \u0026quot;let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\\t]\\%(\\.\\|-\u0026gt;\\)\\|\\h\\w*::' \u0026quot; For perlomni.vim setting. \u0026quot; https://github.com/c9s/perlomni.vim let g:neocomplete#sources#omni#input_patterns.perl = '\\h\\w*-\u0026gt;\\h\\w*\\|\\h\\w*::' 如果只是要用于OI比赛的话，应该只需要前面的一部分.\n希望很久以后我还能看得懂这份配置文件，懒得没修改一次就重新写一次解释了.\n","permalink":"https://seraphim.rocks/posts/%E9%BB%91%E7%A7%91%E6%8A%80/","tags":["stuffs"],"title":"黑科技"},{"categories":null,"contents":"退役之后一直有点消沉，没有写退役记什么的，最近想了想还是多少放点东西上来.\n考挂了的原因有很多，各种意外，和同层次的选手缺少交流等等，或者可以说我觉得自己有进队的实力，但是没有稳进队的实力.\n不过现在再说这些东西意义也没什么意义，丢掉的分不会再回来，我总归还是退役了.\n其实回过头来想想，我也算是比很多人走得远了. 况且，就算我进了队，再多苟半年一年终究是要退役. 所以真的也没什么必要耿耿于怀，只是时不时回想起来，总觉得太过遗憾. 但人生总是要有些不如意的事情，或许十几年过后，再回想起来，这也不过是一件小事.\n 幻梦终醒，本无不散之筵席，却不悔付此华年.\n  这不是开始，也远未结束.\n","permalink":"https://seraphim.rocks/posts/farewelloi/","tags":["stuffs"],"title":"NOI2018退役记"},{"categories":null,"contents":"分治fft是非常明显的做法，不过这样是\\(\\mathcal O(n\\log^2n)\\)的. 把生成函数弄出来之后会发现它是个微分方程，可以有一些神奇的方法来解，具体可以看UR3的题解.\n我比较菜所以还是决定写分治+卡常，发现了一个卡常技巧. 对\\([l,r)\\)区间分治的时候，设\\(m=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor\\)，如果\\(l\\neq0\\)，就要把\\(C(z)\\)，\\(F(z)\\)在\\([l,m)\\)的部分，\\(F(z)\\)在\\([0,r-l)\\)的部分卷起来，这里fft的长度看似要开到\\(4(r-l)\\)，但事实上只需要开到\\(2(r-l)\\)，因为超出\\(2(r-l)\\)的部分小于\\(2(r-l)+(m-l)\\)，这样就算循环到前面去，也会小于\\(m-l\\)，而对\\([m,r)\\)的贡献是从\\(m-l\\)开始的，所以不影响答案. 而\\(l=0\\)的时候fft长度显然也可以只开到\\(2(r-l)\\). 这样一来可以显著减小常数. 跑得比网上搜到的倍增还快！\n另外以后在我学会倍增解微分方程之前，看到微分方程不会解可以考虑分治.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; const ele maxn=(1\u0026lt;\u0026lt;20)+1; const ele MOD=998244353; const ele G=3; const ele inv2=(MOD+1)/2; inline ele\u0026amp; add(ele\u0026amp;a,ele b){ a+=b; return a\u0026gt;=MOD?a-=MOD:a; } inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } ele n,f[maxn],g[maxn],c[maxn],inv[maxn],fac[maxn],ifac[maxn]; char s[maxn]; inline void ntt(ele K,ele n,ele *y){ static ele f[maxn]; f[0]=0; for (int i=1; i\u0026lt;n; ++i){ f[i]=f[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1; if (i\u0026amp;1) f[i]+=n\u0026gt;\u0026gt;1; if (i\u0026lt;f[i]) swap(y[i],y[f[i]]); } for (int p=1; p\u0026lt;n; p\u0026lt;\u0026lt;=1){ ele o=pw(G,(MOD-1)/p/2); o=~K?o:pw(o,MOD-2); for (int i=0; i\u0026lt;n; i+=(p\u0026lt;\u0026lt;1)){ ele o1=1; for (int j=i; j\u0026lt;i+p; ++j,o1=(ll)o1*o%MOD){ ele v=(ll)y[j+p]*o1%MOD; y[j+p]=y[j]; add(y[j],v); add(y[j+p],MOD-v); } } } if (!~K){ ele invn=pw(n,MOD-2); for (int i=0; i\u0026lt;n; ++i) y[i]=(ll)y[i]*invn%MOD; } } void solve(ele l,ele r){ if (r-l\u0026lt;=1){ f[l+1]=(ll)g[l]*inv[l+1]%MOD; return; } ele mid=(l+r)\u0026gt;\u0026gt;1; static ele t1[maxn],t2[maxn],t3[maxn]; solve(l,mid); if (l){ ele tmp=(r-l)\u0026lt;\u0026lt;1; memset(t1,0,sizeof(ele)*tmp); memcpy(t1,c,sizeof(ele)*(r-l)); memset(t2,0,sizeof(ele)*tmp); memcpy(t2,f+l,sizeof(ele)*(mid-l)); memset(t3,0,sizeof(ele)*tmp); memcpy(t3,f,sizeof(ele)*(r-l)); ntt(1,tmp,t1); ntt(1,tmp,t2); ntt(1,tmp,t3); for (int i=0; i\u0026lt;tmp; ++i) t1[i]=(ll)t1[i]*t2[i]%MOD*t3[i]%MOD; ntt(-1,tmp,t1); for (int i=mid; i\u0026lt;r; ++i) add(g[i],t1[i-l]); } else{ ele tmp=(r-l)\u0026lt;\u0026lt;1; memset(t1,0,sizeof(ele)*tmp); memcpy(t1,c,sizeof(ele)*(r-l)); memset(t2,0,sizeof(ele)*tmp); memcpy(t2,f+l,sizeof(ele)*(mid-l)); ntt(1,tmp,t1); ntt(1,tmp,t2); for (int i=0; i\u0026lt;tmp; ++i){ t1[i]=(ll)t1[i]*t2[i]%MOD*t2[i]%MOD; t1[i]=(t1[i]\u0026amp;1)?(t1[i]+MOD)\u0026gt;\u0026gt;1:t1[i]\u0026gt;\u0026gt;1; } ntt(-1,tmp,t1); for (int i=mid; i\u0026lt;r; ++i) add(g[i],t1[i-l]); } solve(mid,r); } int main(){ scanf(\u0026#34;%d%s\u0026#34;,\u0026amp;n,s); ele tmp=1; while (tmp\u0026lt;n) tmp\u0026lt;\u0026lt;=1; fac[0]=1; for (int i=1; i\u0026lt;=tmp; ++i) fac[i]=(ll)fac[i-1]*i%MOD; ifac[tmp]=pw(fac[tmp],MOD-2); for (int i=tmp-1; ~i; --i) ifac[i]=(ll)ifac[i+1]*(i+1)%MOD; for (int i=1; i\u0026lt;=tmp; ++i) inv[i]=(ll)fac[i-1]*ifac[i]%MOD; for (int i=0; i\u0026lt;n; ++i){ c[i]=s[i]-\u0026#39;0\u0026#39;; c[i]=c[i]*ifac[i]; } g[0]=1; solve(0,tmp); for (int i=1; i\u0026lt;=n; ++i) printf(\u0026#34;%lld\\n\u0026#34;,(ll)f[i]*fac[i]%MOD); return 0; } ","permalink":"https://seraphim.rocks/posts/uoj50/","tags":["题解","uoj","多项式","分治","微分方程"],"title":"uoj50题解"},{"categories":null,"contents":"这种求某个东西在最后一个的概率之类的其实可以考虑容斥，设钦定一个集合\\(S\\)在它后面的概率为\\(f(S)\\)，那么最后的答案为\\(\\sum (-1)^{|S|}f(S)\\).\n现在考虑怎么算\\(f(S)\\)，一种感性的方法是，你可以认为其他人就没有关系了，那么\\(f(S)\\)即为第一个人第一个死的概率，即\\(\\frac{w _1}{w _1+\\text{sum}(S)}\\).\n要严谨地证明的话，可以改变一下游戏规则：死去的人不把他踢出去，这样不会改变每个人的死亡顺序，记\\(W=\\sum _{i=1}^n w _i\\)，那么\\(f(S)=\\sum _{i=0}^{+\\infty}\\left(\\frac{W-w _1-\\text{sum}(S)}{W}\\right)^i\\frac{w _1}{W}=\\frac{w _1}{w _1+\\text{sum}(S)}\\).\n于是答案就是\\(\\sum \\frac{(-1)^{|S|}}{w _1+\\text{sum}(S)}\\)，注意到\\(w _i\\)加起来很小，我们可以统计每个\\(\\text{sum}(S)\\)的贡献，这个只需要计算\\(\\prod _{i=2}^n(1-z^{w _i})\\)就可以了.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; static const ele maxn=(1\u0026lt;\u0026lt;18)+1; #define MOD 998244353 #define G 3 inline ele\u0026amp; add(ele \u0026amp;a,ele b){ a+=b; return a\u0026gt;=MOD?a-=MOD:a; } inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } ele n,w[maxn],a[maxn]; inline void ntt(ele K,ele n,ele *y){ static ele f[maxn]; f[0]=0; for (int i=1; i\u0026lt;n; ++i){ f[i]=f[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1; if (i\u0026amp;1) f[i]+=n\u0026gt;\u0026gt;1; if (i\u0026lt;f[i]) swap(y[i],y[f[i]]); } for (int p=1; p\u0026lt;n; p\u0026lt;\u0026lt;=1){ ele o=pw(G,(MOD-1)/p/2); o=~K?o:pw(o,MOD-2); for (int i=0; i\u0026lt;n; i+=(p\u0026lt;\u0026lt;1)){ ele o1=1; for (int j=i; j\u0026lt;i+p; ++j,o1=(ll)o1*o%MOD){ ele u=y[j],v=(ll)y[j+p]*o1%MOD; y[j]=y[j+p]=u; add(y[j],v); add(y[j+p],MOD-v); } } } if (!~K){ ele invn=pw(n,MOD-2); for (int i=0; i\u0026lt;n; ++i) y[i]=(ll)y[i]*invn%MOD; } } ele solve(ele *a,ele l,ele r){ if (l==r){ a[0]=1; a[w[l]]=MOD-1; for (int i=1; i\u0026lt;w[l]; ++i) a[i]=0; return w[l]; } ele mid=(l+r)\u0026gt;\u0026gt;1; ele s1=solve(a,l,mid); ele s2=solve(a+s1+1,mid+1,r); ele tmp=1; while (tmp\u0026lt;=s1+s2) tmp\u0026lt;\u0026lt;=1; static ele t1[maxn],t2[maxn]; memset(t1,0,sizeof(ele)*tmp); memcpy(t1,a,sizeof(ele)*(s1+1)); memset(t2,0,sizeof(ele)*tmp); memcpy(t2,a+s1+1,sizeof(ele)*(s2+1)); ntt(1,tmp,t1); ntt(1,tmp,t2); for (int i=0; i\u0026lt;tmp; ++i) t1[i]=(ll)t1[i]*t2[i]%MOD; ntt(-1,tmp,t1); memcpy(a,t1,sizeof(ele)*(s1+s2+1)); return s1+s2; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for (int i=0; i\u0026lt;n; ++i) scanf(\u0026#34;%d\u0026#34;,w+i); if (n\u0026gt;1){ ele s=solve(a,1,n-1); ele ans=0; for (int i=0; i\u0026lt;=s; ++i) add(ans,(ll)w[0]*a[i]%MOD*pw(w[0]+i,MOD-2)%MOD); printf(\u0026#34;%d\\n\u0026#34;,ans); } else puts(\u0026#34;1\u0026#34;); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2541/","tags":["题解","loj","多项式","容斥"],"title":"loj2541题解"},{"categories":null,"contents":"学到了一个新的技巧，树形的依赖关系，把顺序翻转，就可以在依赖父亲和依赖子树之间相互转化.\n每次选取最深的能选取的叶子，证明的话，画个图用一下调整法应该能证.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;queue\u0026gt;#define ele int #define fi first #define se second using namespace std; #define maxn 100010 ele n,m,ans,f[maxn],dep[maxn],deg[maxn]; vector\u0026lt;ele\u0026gt; res[maxn]; priority_queue\u0026lt;pair\u0026lt;ele,ele\u0026gt; \u0026gt; Q; queue\u0026lt;ele\u0026gt; Q1; int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); dep[0]=0; memset(deg,0,sizeof(deg)); for (int i=1; i\u0026lt;n; ++i){ scanf(\u0026#34;%d\u0026#34;,f+i); --f[i]; ++deg[f[i]]; dep[i]=dep[f[i]]+1; } for (int i=0; i\u0026lt;n; ++i) if (!deg[i]) Q.push(make_pair(dep[i],i)); ans=0; for (int i=0; i\u0026lt;n; ++i){ if (Q.empty()){ ++ans; while (!Q1.empty()){ ele k=Q1.front(); Q1.pop(); Q.push(make_pair(dep[k],k)); } } pair\u0026lt;ele,ele\u0026gt; k1=Q.top(); Q.pop(); ele k=k1.se; if (res[ans].size()==m){ ++ans; while (!Q1.empty()){ ele k=Q1.front(); Q1.pop(); Q.push(make_pair(dep[k],k)); } } res[ans].push_back(k); --deg[f[k]]; if (!deg[f[k]]) Q1.push(f[k]); } printf(\u0026#34;%d\\n\u0026#34;,ans+1); for (int i=ans; ~i; --i){ printf(\u0026#34;%d \u0026#34;,res[i].size()); for (int j=res[i].size()-1; ~j; --j) printf(\u0026#34;%d \u0026#34;,res[i][j]+1); puts(\u0026#34;\u0026#34;); } return 0; } ","permalink":"https://seraphim.rocks/posts/uoj387/","tags":["题解","uoj","贪心"],"title":"uoj387题解"},{"categories":null,"contents":"前置技能：DAG的最小路径覆盖和最小链覆盖.\n算了还是写一下吧免得自己忘了.\n最小路径覆盖的做法就是把每个点\\(i\\)拆成两个点\\(i _0,i _1\\)，边\\((i,j)\\)变成\\((i _0,j _1)\\)，然后做最大匹配，这样每条匹配边相当于原图中一条边，匹配保证了每个点最多有一条入边一条出边，答案就是原图点数-匹配数，因为你可以看成每个点先独立为一条路径，每加入一条边相当于合并两条路径.\n最小链覆盖的话边可以相交，所以需要先用floyd传递闭包，其实就是对于所有点对\\((i,j)\\)求出是否有一条链从\\(i\\)到\\(j\\)，有的话直接连一条边过去，这样两条链相交的话其中一条就可以直接跳过交点.\n题目可以认为是用\\(k\\)条可相交的路径去覆盖这张图，满足一些条件，让边权和最小.\n因为可相交，先考虑来一发传递闭包，因为题目要求，状态要改成\\(g _{i,j}\\)表示只经过编号不超过\\(\\max(i,j)\\)的点，从\\(i\\)到\\(j\\)的最短路，然后对所有\\(i\\lt j\\)，以\\(g _{i,j}\\)为权值连边.\n这样题目就变成了用\\(k\\)条只在\\(0\\)号点相交的路径去覆盖这张图，然后就能够按照DAG最小路径覆盖来建图了，需要注意的是，源点连向\\(0\\)号点的入点的边容量为\\(k\\)，因为这\\(k\\)条路径能在\\(0\\)处相交即\\(0\\)号点出去的边最多可以选\\(k\\)条. 边的费用当然就是\\(g _{i,j}\\).\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#define ele int #define fi first #define se second using namespace std; #define maxn 310 #define maxm 20010 const ele INF=1e9; struct edge{ ele v,r,c; edge *nxt,*rev; }ep[10000000],*ecnt; ele n,m,K,g[maxn][maxn],d[maxn]; bool vis[maxn]; edge *h[maxn],*cur[maxn]; inline void addedge1(ele u,ele v,ele r,ele c){ edge *p=ecnt++; p-\u0026gt;v=v; p-\u0026gt;r=r; p-\u0026gt;c=c; p-\u0026gt;nxt=h[u]; p-\u0026gt;rev=ep+((ecnt-1-ep)^1); h[u]=p; } inline void addedge(ele u,ele v,ele r,ele c){ addedge1(u,v,r,c); addedge1(v,u,0,-c); } inline bool spfa(ele s,ele t){ static queue\u0026lt;ele\u0026gt; Q; for (int i=0; i\u0026lt;n*2+4; ++i) d[i]=INF; d[s]=0; Q.push(s); while (!Q.empty()){ ele k=Q.front(); Q.pop(); for (edge *j=h[k]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;r \u0026amp;\u0026amp; d[k]+j-\u0026gt;c\u0026lt;d[j-\u0026gt;v]){ d[j-\u0026gt;v]=d[k]+j-\u0026gt;c; Q.push(j-\u0026gt;v); } } return d[t]\u0026lt;INF; } pair\u0026lt;ele,ele\u0026gt; dfs(ele i,ele t,ele p){ if (!p || i==t) return make_pair(0,p); ele ans=0,ans1=0; vis[i]=true; for (edge*\u0026amp;j=cur[i]; j; j=j-\u0026gt;nxt) if (!vis[j-\u0026gt;v] \u0026amp;\u0026amp; j-\u0026gt;r \u0026amp;\u0026amp; d[i]+j-\u0026gt;c==d[j-\u0026gt;v]){ pair\u0026lt;ele,ele\u0026gt;tmp =dfs(j-\u0026gt;v,t,min(p,j-\u0026gt;r)); if (tmp.se){ ans+=tmp.fi; ans+=j-\u0026gt;c*tmp.se; ans1+=tmp.se; j-\u0026gt;r-=tmp.se; j-\u0026gt;rev-\u0026gt;r+=tmp.se; p-=tmp.se; if (!p) break; } else d[j-\u0026gt;v]=INF; } return make_pair(ans,ans1); } inline ele mincost(ele s,ele t){ ele ans=0; while (spfa(s,t)){ memset(vis,0,sizeof(vis)); memcpy(cur,h,sizeof(h)); ans+=dfs(s,t,INF).fi; } return ans; } int main(){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;K); for (int i=0; i\u0026lt;=n; ++i) for (int j=0; j\u0026lt;=n; ++j) g[i][j]=INF; while (m--){ ele u,v,w; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); g[u][v]=g[v][u]=min(g[u][v],w); } for (int k=0; k\u0026lt;=n; ++k) for (int i=0; i\u0026lt;=n; ++i) for (int j=0; j\u0026lt;=n; ++j) if (max(i,j)\u0026gt;=k) g[i][j]=min(g[i][j],g[i][k]+g[k][j]); ecnt=ep; memset(h,0,sizeof(h)); for (int i=0; i\u0026lt;=n; ++i) for (int j=i+1; j\u0026lt;=n; ++j) addedge(2+i*2,2+j*2+1,1,g[i][j]); addedge(0,2,K,0); for (int i=1; i\u0026lt;=n; ++i) addedge(0,2+i*2,1,0); for (int i=0; i\u0026lt;=n; ++i) addedge(2+i*2+1,1,1,0); printf(\u0026#34;%d\\n\u0026#34;,mincost(0,1)); return 0; } ","permalink":"https://seraphim.rocks/posts/bzoj2324/","tags":["题解","bzoj","网络流"],"title":"bzoj2324题解"},{"categories":null,"contents":"NOI前的垂死挣扎.7-1 考得还不错的样子，但是还有可以完善的地方.\nT1 想到了出题人想到的状压dp，然后别人想出来了一个\\(\\mathcal O(n^3)\\)的dp. 其实我是看到了题目的\\(n\\le 24\\)就去想状压的，如果数据范围大一点我应该也能想到？\nT2 被卡常卡成60分了，主要是因为方点的情况我强行把分治FFT的做法搬过来写出了8倍常数. 事实上比赛的时候我已经注意到了方点相当于是没有度数限制的，而用在圆点上的分治FFT本来就是为了处理度数限制的问题，所以完全没有必要照搬，可以直接用一个线性的dp解决方点的情况.\nT3 写完+检查完前两道题的时候已经过去4h了，写暴力又花了一些时间导致我没什么时间想这道题. 当时我已经想出了\\(\\mathcal O(n^3)\\)的dp做法，其实再注意到一些细节就可以优化到\\(\\mathcal O(n)\\)，但是剩下的时间连打完我想到的那个dp都很勉强. 说到底还是我思维比较迟缓，并且码力太过底下，前面debug了太长的时间，还是要多做点题.\n7-2 区分度极低+极度劝退，rk8后面就是rk29. 很荣幸能够挤进前10.T1 挺不错的一道题，链剖的做法也没有那么容易想到，不过想到了的话打起来非常舒服.\nT2 没怎么卡过空间，各种会分块会主席树但是MLE……\n首先询问区间中有多少种数是经典的难以合并信息的问题，询问一个区间还有分块或者主席树的做法，询问多个区间的话，没什么好的想法，就只能bitset卡一卡了.\n用bitset的话第一个问题是想办法做到\\(\\mathcal O(\\frac{nm}{w})\\)而不是\\(\\mathcal O(\\frac{nm\\log n}{w})\\). 直接ST表的话会MLE. 如果可以离线，就能用莫队把每个询问区间的bitset预处理出来. 其实反正已经用了bitset这么暴力的东西了，不妨维护的时候也暴力一点，把整个区间分成\\(w\\)个块，预处理出\\(w^2\\)个块对之间的bitset，每个询问区间在整块的基础上加上\\(\\mathcal O(\\frac{n}{w})\\)个数. 这样子空间开不下，可以把预处理\\(w^2\\)个块对改为用ST表维护各个块，就能把空间卡进去了.\nT3 差分之后按位置模\\(k\\)分类然后计算交错和什么的都很容易想到，关键是判无解非常麻烦，在左右端点需要特殊处理的情况下判无解更加麻烦，反正我在赛场上没想到优美的方法. 标解是利用hash，给每个模\\(k\\)的余数分配一个\\([0,2^{64})\\)之间的随机权值，那么计算询问区间中的\\(1\\)的位置的异或和再进行判断就可以了. 要注意求多类位置分别的前缀交错和的和写法比较特殊，要让\\(f _i\\)表示让最后一个位置的权值为\\(+1\\)时的前缀交错和，这样区间中每类位置均出现偶数次的时候，就能拿两个前缀和做个差得到区间交错和了.\n7-3 似乎基本都听过一遍？\n7-4 除去std还有11个人ak，我是第12名. 后来可能还重测了几个丢了程序的人.\nT1 我的做法是想象高维空间，一个\\(n+1\\)维的基础图形实际上就是由\\(n\\)维的在第\\(n+1\\)维上平移得到的. 那么平移前后，每一维成分的数量首先是翻了一倍，另外平移前和平移后对应的\\(j-1\\)维的成分构成了一个\\(j\\)维的成分. 以二维到三维为例，一个正方形向上平移，得到了\\(8\\)个点和\\(8\\)条边，设平移前正方形为\\(A\\)，平移后正方形为\\(B\\)，那么\\(A\\)和\\(B\\)的每对对应点形成一条新的边，每对对应边形成一个新的面. 设\\(f _{i,j}\\)为\\(i\\)维基础图形中\\(j\\)维的个数，即有\\(f _{i,j}=2f _{i-1,j}+f _{i-1,j-1}\\)，记\\(F _i(z)=\\sum f _{i,j}z^j\\)，即有\\(F _{i+1}(z)=(2+z)F _i(z)\\)即\\(F _n(z)=(2+z)^n\\)，那么\\(f _{n,m}=2^{n-m}\\binom{n}{m}\\).\nT2 跟以前见过的一道dp题比较像. 考虑从小到大决策每个元素，它的贡献依赖于前面的元素的决策，但是这个不方便表示为状态. 假设当前要加入的元素为\\(i\\),可以把前面的元素分成跟\\(i\\)加在一起无贡献和有贡献的两部分，有贡献的部分只需要保存两边的数量就可以了，而无贡献的部分随着\\(i\\)的增大只会不断减少，所以我们可以先不决策无贡献的部分，当其中的元素变成有贡献的时候再进行决策，到最后都还是无贡献的那一部分放在哪边都不影响答案，所以最后乘一个\\(2^\\textrm{cnt}\\)即可.\nT3 居然没想出来真是丢人. 我想到了容斥而且会做\\(k=0\\)居然还做不出来，可能是因为我总是想着一步把式子推到位，而没有把一些关键的量记为一个符号来简化思考.\n显然这道题就是要求极长同色子段恰有\\(n-k\\)个的方案数，用指数生成函数很容易算出段数不超过\\(i\\)的元次\\(f _i\\). 其实这个时候就可以凑容斥系数了. 考虑一个实际有\\(i\\)段的方案，它只对\\(j\\ge i\\)的\\(f _j\\)有贡献，且贡献的系数为\\(\\binom{n-i}{j-i}\\). 这是因为有\\(i\\)段相当于切了\\(i-1\\)刀，还有\\(n-i\\)个位置可以切，为了被算进\\(f _j\\)里面，还需要切\\(j-i\\)刀，所以共\\(\\binom{n-i}{j-i}\\)种切法. 于是我们可以列出式子\n\\[\\sum _{j=i}^nc _j\\binom{n-i}{j-i}=[i=n-k] \\]\n化得好看一些\n\\[\\sum _{p=0}^{n-i}c _{i+p}\\binom{n-i}{p}=[k=n-i] \\]\n右边这个东西如果利用\\([n=0]=\\sum (-1)^i\\binom{n}{i}\\)来做，反正我不会. 注意到\\(i\\le n-k\\)（否则不可能有贡献，一般不会去考虑），可以启发我们展开\\((z+1-1)^{n-i}\\)，得到\n\\[[z^k] (z+1-1)^{n-i}=\\sum 1^p(-1)^{n-i-k-p}\\frac{(n-i)!}{k!p!(n-i-k-p)!} \\]\n于是有\n\\[c _{i+p}=\\frac{(-1)^{n-i-k-p}(n-i-p)!}{k!(n-i-k-p)!} \\]\n也就是\\(c _j=(-1)^{n-k-j}\\binom{n-j}{k}\\).\n如果不想凑系数的话，也可以考虑求一个\\(g _i\\)表示恰好有\\(i\\)段的方案数. 注意到\\(f _i=\\sum _{j\\le i}g _j\\binom{n-j}{i-j}\\)，强行反演其实就相当于上面的凑系数，或者你也可以写成\\((n-i)!g _i=(n-i)!f _i-\\sum _{j\\lt i}(n-j)!g _j\\cdot\\frac{1}{(i-j)!}\\)，用多项式求逆的套路让\\(F(z)=\\sum(n-i)!f _iz^i,G(z)=\\sum(n-i)!g _iz^i\\)，就有\\(G(z)=F(z)-(e^z-1)G(z)\\)，即\\(G(z)=F(z)e^{-z}\\).\n感觉这是一道挺不错的计数题，这里面包含的几个新套路，一个是展开\\((z+1-1)^{n-i}\\)，一个是\\(\\binom{n-i}{j-i}\\)这个系数，都要记下来.\n7-5 T1 题目保证给定的点都在凸包上，所以询问区间中的点一定都在这些点的凸包上，也就是说只需要计算\\(\\sum _{i=0}^{L-1}P _i\\times P _{i+1}(P _L=P _0)\\)，其中\\(L\\)为询问区间的长度\\(P _0,P _1,\\ldots,P _{L-1}\\)为询问区间中的点按照极角排序之后的结果.\n那么\\(\\mathcal O(n\\sqrt{n}\\log n)\\)的莫队就是显然的了. 想办法继续优化，注意到插入是\\(\\mathcal O(\\log n)\\)的，但删除可以做到\\(\\mathcal O(1)\\)，可以用删除的撤销来代替插入. 具体来讲，把询问排序的时候，右端点从小到大改为从大到小，设当前询问区间的左端点所在块的左端点为\\(l _0\\)，维护\\([l _0,n)\\)的凸包，每次询问的时候移动端点就只需要删除了，询问结束后恢复左端点. 如果左端点所在的块变化了，就恢复右端点，然后把左边的块删掉（此次不用恢复）. 只有插入的莫队思路略有不同，挺好想的就不讲了.\n只有插入或者只有删除的莫队算是个以前没见过的技巧吧，要记下来.\nT2 可以用各种方法花式AC，稍微记录一下感觉比较有意思的.\n这一个是我用的方法，答案保证严格大于\\(\\frac{n}{2}\\)，所以中位数一定在答案里面，第一次输入把所有的数按照高\\(16\\)位分类，那么答案只可能在最中间的三类里面，第二次输入的时候把中间三类的数的低\\(16\\)位存在\\(3\\)个桶里，然后暴力就可以了.\n另外有一个挺有意思的随机化的做法，因为答案超过一般，随机选择\\(20\\)个位置，那么有很大概率至少选到了一个在答案里面的数，第二次读入的时候分别钦定这\\(20\\)个数在答案里，分别算出答案取最优.\nT3 这个题的构造也不知道是怎么想出来的，非构造解法晚点再研究吧.\n从\\(m=2\\)入手，定义\\(g _0=g _1=g _2=1,g _n=g _{n-1}+g _{n-2}(n\\ge 3)\\)，那么神仙具有敏锐洞察力的选手就可以观察到如果\\(g _n=\\sum _{i=1}^kg _{a _i}\\)，这里\\(a _1\\gt a _2\\gt\\cdots\\gt a _k\\ge 2\\)（容易证明一定有这样的一个划分），那么\\(f(n)=\\sum _{i=1}^kg _{a _i-1}\\).\n为什么是这样呢？首先把题目里面的式子移项，得到\\(f(n)+f _m(n-1)=n\\)，又有\n\\[\\begin{aligned}n\u0026=\\sum _{i=1}^kg _{a _i}\\\\\\\\f(n)\u0026=\\sum _{i=1}^kg _{a _i-1}\\\\\\\\f _2(n)\u0026=\\sum _{i=1}^kg _{a _i-2}\\end{aligned} \\]\n后面两个式子加起来跟前一个比较，发现如果是\\(f(n)+f _m(n)=n\\)，似乎就有\\(g _n=g _{n-1}+g _{n-2}\\)了. 但是这里是\\(n-1\\).\n注意到\\(n-1\\)的分拆里面，前\\(k-1\\)个数跟\\(n\\)的分拆肯定是一样的，因而前\\(k-1\\)项仍满足上式，我们讨论\\(g _{a _k}\\).\n  \\(g _{a _k}=1\\)，此时\\(n-1\\)的分拆没有最后一项，因为\\(1=1+0\\)，最后一项仍满足上式.\n  \\(g _{a _k}1\\)，此时相当于\\(f _2(n-1)\\)的分拆最后一项变成了\\(f _2(g _{a _k}-1)\\)的分拆形式，由题目我们知道它等于\\(g _{a _k}-f(g _{a _k})=g _{a _k}-g _{a _k-1}=g _{a _k-2}\\)，即最后一项仍满足上式.\n  规定\\(g _0=1\\)而不是\\(g _0=0\\)是因为要考虑\\(f(1)\\).\n对于一般的情况，定义\\(g _0=g _1=\\cdots=g _m=1,g _n=g _{n-1}+g _{n-m}(n\\gt m)\\)即可.\n其实这个时候你会发现如果那一项是\\(f _m(n)\\)的话反而可能会出一些问题.\n7-7 网络流题好像有一个比较常见的思路是，当每个东西有多个决策的时候，先全部假定一下，然后再用网络流去调整.\n7-8 挂了挂了……\nT1 最小树形图的朱刘算法.\n也不知道出题人是怎么想的……\nT2 我的做法似乎比std更nb一些？反正std4k跑5s，我的代码2.4k跑0.5s.\n定义每个软件包开始安装的时间为\\(S _i\\)，实际安装花费的时间为\\(a _i\\)，最后答案为\\(T\\). 那么首先有\\(\\forall(i,j)\\in E,S _j-S _i\\ge a _i\\). 总花费不超过\\(w\\)，可以表示成\\(\\sum c _i(t _i-a _i)\\le w\\). 由题显然有\\(0\\le a _i\\le t _i\\). 最后答案其实相当于是对\\(S _i+a _i\\)取\\(\\max\\)，可以加入\\(n\\)个约束\\(T\\ge S _i+a _i\\)，然后就是要在满足上面所有这些约束的前提下最小化\\(T\\)，直接上单纯形就可以了.\n考试的时候我想到了基本相同的思路，但是没有往线性规划的方向去想，强行建了一个点数极多的图，还不知道哪里写错了一点东西，最后没拿到分. 其实网络流和线性规划很多地方是有联系的，以后想网络流建图类的问题时，不妨结合线性规划一起想，毕竟有的时候网络流更简单一些，有的时候线性规划更简单一些.\n出题人列出的线性规划式子要考虑每一条路径，所以约束个数可能达到指数级，要先对偶再转化成网络流来做. 我列出的式子和出题人不太一样，只有\\(\\mathcal O(n)\\)个变量，\\(O(n+m)\\)个约束，直接跑单纯形就非常快了.\n不过现在还遗留了一个小问题，无论是我的做法还是出题人的做法，似乎都不能保证减少之后的安装时间是整数. 我想了一想，觉得好像可以证明至多只有一个\\(a _i\\)不是整数，所以最后只需要把答案向上取整就可以了，当然有单纯形的话需要考虑一下精度问题，先减去一个eps再向上取整. 出题人的做法要二分答案，所以只需要把二分的精度限制在整数就可以了.\nT3 毒瘤！\n7-9 今天的题目是上交的，长得根本不像NOI模拟赛……\n题目比较水，而我第二题被卡常卡掉了52分，最后只能排rk29.\nT1 水题.\n不过倒是学到了一个东西：线性预处理\\(1,2,\\ldots,n\\)逆元的(MOD-MOD/i)*inv[MOD%i]的做法虽然看上去很炫酷，但是里面用了除法，实际上常数很大，需要卡常的时候得注意一下.\nT2 第一反应是世界树那道题，我以前因为太难码放弃了，这回在考场上硬生生码了200+行代码写了出来，可是A掉了bzoj的世界树那题，模拟赛里面的这道题却被卡常卡成48分了.\n事实上这道题是世界树那道题的简化版，有一个常数应该更小的做法. 这道题目只需要询问\\(a _1\\)占领了哪些点，所以可以对每个\\(j\\in[2,k]\\)，求出\\(a _1\\)与\\(a _j\\)的中点\\(m _j\\)，那么\\(m _j\\)靠\\(a _j\\)的那一边肯定不会被\\(a _1\\)占领，这对应着树上的一棵子树或除了一棵子树以外的其它部分，而对每个\\(a _j\\)去掉那些部分之后，剩下的就是\\(a _1\\)可以占领的点了. 这样只需要用一棵线段树在dfs序上做区间修改，应该比虚树的做法好写很多.\nT3  题目：为了锻炼你的水平，建议使用在线算法.\n我：我没有水平，我离线！\n 于是我就写了一个按时间分治水了过去. 其实码力低下的我还是因为一个弱智的bug耽搁了很久.\n考虑在线算法，如果只在一段加和删，那显然可以直接做背包，删除可以看做是插入的撤销，直接再插入的时候做一个之前时刻的备份就可以了. 如果在两端加和删，可以在两端分别用一个背包来维护，每次查询相当于是要把两个背包合并起来，直接合并是\\(\\mathcal O(\\text{MOD}^2)\\)的，但是因为只需要合并两个背包而不是多个，也只需要求合并后一段区间里面的最值，而不是背包的完整信息，可以枚举其中一个背包中的值，然后在另一个背包里做区间查询，复杂度降到\\(\\mathcal O(\\text{MOD}\\log\\text{MOD})\\).\n加入删除之后会出现一个问题，就是一边背包被删空了会开始删另一个背包的另一端. 一个显然的思路是暴力把另一个背包栈的开口反向，但这样的话如果左边删一个右边删一个循环的话复杂度就不对了. 解决方法也很简单，这种时候把另一个背包的一半元素分离出来，反向，另一半保持不变，均摊分析一下会发现复杂度是\\(\\mathcal O(\\text{MOD}\\log m)\\)的.\n最后，这个在线算法的复杂度为\\(\\mathcal O(m\\text{MOD}(\\log\\text{MOD}+\\log m))\\).\n7-10 本来应该200分rk3的……一定要吸取教训. 我T2打了一个\\(\\mathcal O(m\\sqrt{L}\\log L)\\)的做法，本来可以拿90分，但是数组开得比较大MLE了，但事实上是跑不满的，这也就导致用任务管理器之类的东西看内存消耗看的也远小于开的数组的大小. 可是很多评测软件看的是你开了多少而不是用了多少，所以以后还是尽量要手算空间，如果觉得跑不满又开不下，还是用vector或者别的一些方法动态开空间吧. 这个一定要记住，今天这种情况真的非常可惜.\nT2 这种题对于\\(\\gt\\sqrt{L}\\)的情况要善于勇敢地暴力，做这道题的时候我考虑\\(\\gt\\sqrt{L}\\)的情况考虑了很久，最后发现单独处理这些串的时候，每个串就算是暴力枚举前缀，暴力与前面的比对，复杂度都是对的.\n还是写一下做法吧怕自己忘了. 记\\(L=\\sum|s _i|\\)，对于每个询问考虑\\(|S|\\le\\sqrt{L}\\)和\\(|S|\\gt\\sqrt{L}\\)两种情况.\n对于第一种情况，各种套路想一遍发现按右端点排序来做的套路比较靠谱，设\\(f _{i,j}\\)代表以\\(i\\)为右端点，要使得存在长度为\\(j\\)的前缀有贡献，左端点最右的位置，这个可以根据\\(f _{i-1,j}\\)和\\(i\\)这个串长度为\\(j\\)的前缀的贡献来计算. 要计算后者，可以把所有串长度不超过\\(\\sqrt{L}\\)的前缀取出来，记录一个\\(\\text{pos} _s\\)表示以\\(s\\)为前缀的串的位置列表，然后在上面查就可以了. 事实上因为\\(f\\)可以存下来，这一步不需要离线.\n对于第二种情况，有贡献的串至多\\(\\sqrt{L}\\)个，把询问按照包含这些串的区间分类，离线下来，记第\\(i\\)个询问包含这些串的区间是\\([u _i,v _i]\\). 以\\(u\\)为第一关键字，\\(v\\)为第二关键字排序，这样固定\\(u\\)之后\\(v\\)增大就相当于在后面暴力加串. 加串的话，可以暴力枚举前缀，然后暴力扫一遍前面的串来统计这个前缀的出现次数，判断它有没有贡献（要事先预处理长度\\(\\gt\\sqrt{L}\\)的串两两之间的lcp，这个也可以暴力预处理）. 这样加串的总复杂度不超过\\(\\sum\\sqrt{L}|S|=L\\sqrt{L}\\)，同样暴力预处理lcp的复杂度也不超过这个.\n按照以上的方法就可以求出有贡献的长度的集合，要统计答案，支持加一个长度和删一个长度，随便用个数据结构就可以维护了.\n但这样是\\(\\mathcal O(m\\sqrt{L}\\log L)\\)的，跑最后一个点很悬. 如果要继续优化的话，注意到只有插入会带\\(\\log\\)，删除不会，使用熟悉的套路，把插入看成删除的撤销即可. 具体来讲，\\(\\le\\sqrt{L}\\)的部分全程删除和全程插入是一样的，因为原来算法是把有贡献的插入，改成一开始全部插入好，利用\\(f\\)数组找出没贡献的删掉就行了，最后再恢复成删掉之前的样子来处理下一个询问. 至于\\(\\gt\\sqrt{L}\\)的部分，改成\\(u\\)从小到大，\\(v\\)从大到小，就变成全程都是删除了.\n再讲讲我不优化算法是怎么卡常卡进去的. 首先维护的数据结构不要用set或者线段树这么大常数的东西，用zkw，顺手把删除写成\\(\\mathcal O(1)\\)的，再加个读入优化，这个时候已经从12s优化到4.9s了，放到lemon上面跑的时候因为玄学原因变快了一些就过了.\nT3 先坑着.\n7-12 居然rk1了？\nT1 先坑着.\nT2 首先一个很显然的思路是链上修改单点查询转化为单点修改子树查询，然后就可以做树上的启发式合并，来得到每个点对应的trie了. 事实上trie的合并可以像线段树合并那样做，就可以少一个\\(\\log\\). 求期望的路径长度的话，每个点记一个\\(f _i\\)表示从\\(i\\)出发的期望步数，它的转移跟父亲有关，有一个经典的技巧是把\\(f _i\\)表示成\\(a _i+b _if _{\\text{fa} _i}\\)的形式，这样就可以不用高斯消元，第一遍dfs先把\\(a,b\\)求出来，第二遍dfs把\\(f\\)求出来. 不过此题要算的是所有\\(f\\)的和，而且还要动态维护，所以再记一个\\(s _i\\)表示以\\(i\\)为根的子树的\\(f\\)的和，发现\\(s _i\\)也可以表示为\\(c _i+d _if _{\\text{fa} _i}\\)的形式. \\(a,b,c,d\\)都可以很方便地在trie上动态维护，这样就能快速地求出答案了.\n评测的时候最后两个点好像爆栈了？但是noi应该会开无限栈的吧.\nT3 一开始的时候觉得多项式开根常数太大了，就写了个分治来求\\(f\\)，结果\\(b _i\\le 10^5\\)的点跑了6.7s. 麦老大说开根常数再大也不会比\\(\\mathcal O(n\\log^2n)\\)的分治慢. 膜拜10min打完多项式板子的dalao……\n假设我们已经把\\(f _i\\)求出来了，考虑一个简单一点的问题，已经知道\\(x,x^2,x^3,\\ldots,x^n\\)，怎么求出\\(x^{n+1}\\). 这个显然用脚都能求出来. 但是现在它是一堆东西加起来，所以应该使用线性的方法，换句话说可以考虑把\\(x^{n+1}\\)表示成\\(x,x^2,x^3,\\ldots,x^n\\)的线性组合. 回忆一下在哪里干过类似的事，可以联想到求常系数线性递推的时候，把\\(M^n\\)表示成\\(I,M,M^2,\\ldots,M^{n-1}\\)的线性组合. 当时是利用了\\(M\\)的化零多项式，容易想到现在也要构造一个多项式\\(p(t)\\)使得\\(f _{b _1},f _{b _2},\\ldots,f _{b _n}\\)是它的根，显然\\(p(t)=\\prod(t-f _{b _i})\\)，这个用分治fft来求就可以了.\n下面考虑一下如何更高效地求出\\(f _i\\). 我们知道\\(f _i\\)的生成函数\\(F(z)=\\frac{1-\\sqrt{1-4z^2-16z^3-16z^4}}{2z(1+2z)}\\)，这是一个多项式开根的经典题目，但是这里它有一个特殊性质，就是这些式子的次数都很低，不妨把它写成\\(\\frac{A(z)-\\sqrt{C(z)}}{B(z)}\\)的形式，先考虑怎么算\\(D(z)/B(z)=X(z)\\)，移项得到\\(B(z)X(z)=D(z)\\)，代入\\(B(z)=2z(1+2z)\\)，比较\\(z^n\\)的系数，得到\\(d _n=2x _{n-1}+4x _{n-2}\\)，即\\(x _n=\\frac{d _{n+1}-4x _{n-1}}{2}\\)，这样就可以线性递推了. 接下来考虑怎么计算\\(\\sqrt{C(z)}=Y(z)\\)，求导得到\\(Y^\\prime(z)=\\frac{C^\\prime(z)Y(z)}{2C(z)}\\)，即\\(2C(z)Y^\\prime(z)=C^\\prime(z)Y(z)\\). 代入再比较\\(z^n\\)的系数，得到\\(2((n+1)h _{n+1}-4(n-1)h _{n-1}-16(n-2)h _{n-2}-16(n-3)h _{n-3})=-8h _{n-1}-48h _{n-2}-64h _{n-3}\\)，把下标平移一下再化简，得到\\(nh _n=(4n-12)h _{n-2}+(16n-72)h _{n-3}+(16n-96)h _{n-4}\\). 这样就可以线性递推了.\n感觉有的时候求个导可以得到一些奇奇怪怪的但是有用的东西.\n","permalink":"https://seraphim.rocks/posts/yali201807/","tags":["题解","stuffs"],"title":"雅礼2018年7月集训总结"},{"categories":null,"contents":"又写了一遍，tarjan真的容易写错……\n如果没有x类型显然就是2SAT，如果有的话一个很自然的想法就是枚举它是A，B还是C. 但是注意到我们在做2SAT，只要把可能的情况限制在2种以内就可以了. 所以对于x类型的地图，可以枚举它不是A和它不是B两种情况（不需要枚举不是C，因为这肯定包含在前两种情况里面）.\n错误的tarjan：\nvoid tarjan(ele i){ dfn[i]=low[i]=tcnt++; instack[i]=true; stk[top++]=i; for (edge *j=h[i]; j; j=j-\u0026gt;nxt) if (!~dfn[j-\u0026gt;v]){ tarjan(j-\u0026gt;v); low[i]=min(low[i],low[j-\u0026gt;v]); } else if (instack[j-\u0026gt;v]) low[i]=min(low[i],dfn[j-\u0026gt;v]); if (low[i]==dfn[i]){ bool r=true; for (int j=top-1; ; --j){ if (ans[stk[j]] || ans[stk[j]^1]) r=r \u0026amp;\u0026amp; ans[stk[j]]; if (stk[j]==i) break; } do{ ans[stk[top-1]]=r; ans[stk[top-1]^1]=r^1; blg[stk[top-1]]=bcnt; --top; }while (stk[top]!=i); ++bcnt; } instack[stk[top-1]]=false; } 正确的tarjan：\nvoid tarjan(ele i){ dfn[i]=low[i]=tcnt++; instack[i]=true; stk[top++]=i; for (edge *j=h[i]; j; j=j-\u0026gt;nxt) if (!~dfn[j-\u0026gt;v]){ tarjan(j-\u0026gt;v); low[i]=min(low[i],low[j-\u0026gt;v]); } else if (instack[j-\u0026gt;v]) low[i]=min(low[i],dfn[j-\u0026gt;v]); if (low[i]==dfn[i]){ bool r=true; for (int j=top-1; ; --j){ if (ans[stk[j]] || ans[stk[j]^1]) r=r \u0026amp;\u0026amp; ans[stk[j]]; if (stk[j]==i) break; } do{ ans[stk[top-1]]=r; ans[stk[top-1]^1]=r^1; blg[stk[top-1]]=bcnt; instack[stk[top-1]]=false; --top; }while (stk[top]!=i); ++bcnt; } } tarjan一定要注意栈的问题，目前发现的易错点一个是忘了弹栈（写圆方树的时候，如果是一条树边，需要弹栈），一个是在错误的地方弹栈（在有向图的dfs树里会有横叉边，instack里面 不能 只保存当前点到根路径上的点，参考上面的代码）.\n完整的AC代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int using namespace std; #define maxn 100010 #define maxm 200010 struct rl{ ele i,hi,j,hj; }a[maxn]; struct edge{ ele v; edge *nxt; }ep[maxm],*ecnt; ele n,d,m,tcnt,bcnt,top,stk[maxn],b[maxn],dfn[maxn],low[maxn],blg[maxn]; char s[maxn]; bool flag,ans[maxn],instack[maxn]; edge *h[maxn]; inline void addedge(ele u,ele v){ edge *p=ecnt++; p-\u0026gt;v=v; p-\u0026gt;nxt=h[u]; h[u]=p; } inline ele idx(ele i,ele j){ j=(j-b[i]+2)%3; return i\u0026lt;\u0026lt;1|j; } void tarjan(ele i){ dfn[i]=low[i]=tcnt++; instack[i]=true; stk[top++]=i; for (edge *j=h[i]; j; j=j-\u0026gt;nxt) if (!~dfn[j-\u0026gt;v]){ tarjan(j-\u0026gt;v); low[i]=min(low[i],low[j-\u0026gt;v]); } else if (instack[j-\u0026gt;v]) low[i]=min(low[i],dfn[j-\u0026gt;v]); if (low[i]==dfn[i]){ bool r=true; for (int j=top-1; ; --j){ if (ans[stk[j]] || ans[stk[j]^1]) r=r \u0026amp;\u0026amp; ans[stk[j]]; if (stk[j]==i) break; } do{ ans[stk[top-1]]=r; ans[stk[top-1]^1]=r^1; blg[stk[top-1]]=bcnt; instack[stk[top-1]]=false; --top; }while (stk[top]!=i); ++bcnt; } } void dfs(ele i){ if (flag) return; if (i==n){ ecnt=ep; memset(h,0,sizeof(h)); for (int j=0; j\u0026lt;m; ++j){ if (a[j].hi==b[a[j].i]) continue; ele u=idx(a[j].i,a[j].hi); if (a[j].hj==b[a[j].j]) addedge(u,u^1); else{ ele v=idx(a[j].j,a[j].hj); addedge(u,v); addedge(v^1,u^1); } } memset(dfn,-1,sizeof(dfn)); tcnt=bcnt=top=0; memset(ans,0,sizeof(ans)); for (int j=0; j\u0026lt;(n\u0026lt;\u0026lt;1); ++j) if (!~dfn[j]) tarjan(j); for (int j=0; j\u0026lt;n; ++j) if (blg[j\u0026lt;\u0026lt;1]==blg[j\u0026lt;\u0026lt;1|1]) return; for (int j=0; j\u0026lt;n; ++j){ ele u=(b[j]+1+ans[j\u0026lt;\u0026lt;1|1])%3; putchar(\u0026#39;A\u0026#39;+u); } puts(\u0026#34;\u0026#34;); flag=true; return; } if (s[i]!=\u0026#39;x\u0026#39;){ b[i]=s[i]-\u0026#39;a\u0026#39;; dfs(i+1); } else{ b[i]=0; dfs(i+1); if (flag) return; b[i]=1; dfs(i+1); } } int main(){ scanf(\u0026#34;%d%d%s%d\u0026#34;,\u0026amp;n,\u0026amp;d,s,\u0026amp;m); for (int i=0; i\u0026lt;m; ++i){ ele _a,c; char b[5],d[5]; scanf(\u0026#34;%d%s%d%s\u0026#34;,\u0026amp;_a,b,\u0026amp;c,d); a[i]=(rl){_a-1,b[0]-\u0026#39;A\u0026#39;,c-1,d[0]-\u0026#39;A\u0026#39;}; } flag=false; memset(instack,0,sizeof(instack)); dfs(0); if (!flag) puts(\u0026#34;-1\u0026#34;); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2305/","tags":["题解","loj","2SAT","tarjan"],"title":"loj2305题解"},{"categories":null,"contents":"要知道某个数的最高位，其实就是要知道它对数的小数部分，于是可以想到维护对数的和.\n因为要给区间排序，容易想到线段树合并的做法，不过这里还要进行区间查询而非单点查询，理论上外面还需要套一个平衡树之类的东西，但这样就非常难写了.\n注意到线段树合并的做法本来外面套着一个类似ODT的东西，而这道题的排序操作正好就相当于是区间覆盖，所以外面可以套ODT而不是平衡树，就非常好写了.\n如果直接就这么交上去，你会发现前面有几个点T掉了，再仔细读一遍题，发现\n 对于\\(20\\%\\)的数据：没有操作1\n 还需要对这20分专门写个暴力.\n这种题精度很成问题，本来应该有spj，然后规定跟std输出不同的数不超过若干个就算A，可是这题没spj，那就得要跟出题人心灵相通了.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;cmath\u0026gt;#define ele int #define db double using namespace std; #define maxn 200010 #define K 500000 template\u0026lt;class T\u0026gt;struct mempool{ T *s,*t; mempool(){ s=t=NULL; } inline T* alloc(){ return s==t \u0026amp;\u0026amp; (t=(s=new T[K])+K),s++; } }; struct node{ ele s; db s1; node *l,*r; node(){ s=0; s1=0; l=r=NULL; } }; ele n,m,a[maxn],tg[maxn]; db s1,s[maxn]; set\u0026lt;ele\u0026gt; S; node *T[maxn]; mempool\u0026lt;node\u0026gt; np; inline void maintain(node *x){ x-\u0026gt;s=0; x-\u0026gt;s1=0; if (x-\u0026gt;l) x-\u0026gt;s+=x-\u0026gt;l-\u0026gt;s,x-\u0026gt;s1+=x-\u0026gt;l-\u0026gt;s1; if (x-\u0026gt;r) x-\u0026gt;s+=x-\u0026gt;r-\u0026gt;s,x-\u0026gt;s1+=x-\u0026gt;r-\u0026gt;s1; } node* upd(node *x,ele u,ele v,ele i){ if (!x) x=np.alloc(); x-\u0026gt;s=1; x-\u0026gt;s1=log10(i); if (u!=v){ ele mid=(u+v)\u0026gt;\u0026gt;1; if (i\u0026lt;=mid) x-\u0026gt;l=upd(x-\u0026gt;l,u,mid,i); else x-\u0026gt;r=upd(x-\u0026gt;r,mid+1,v,i); } return x; } node* merge(node *a,node *b){ if (!a) return b; if (!b) return a; a-\u0026gt;s+=b-\u0026gt;s; a-\u0026gt;s1+=b-\u0026gt;s1; a-\u0026gt;l=merge(a-\u0026gt;l,b-\u0026gt;l); a-\u0026gt;r=merge(a-\u0026gt;r,b-\u0026gt;r); return a; } void split(node *x,ele k,ele u,ele v,node*\u0026amp;a,node*\u0026amp;b){ if (!x){ a=b=NULL; return; } node *p=np.alloc(); if (!x-\u0026gt;l \u0026amp;\u0026amp; !x-\u0026gt;r){ p-\u0026gt;s=x-\u0026gt;s-k; x-\u0026gt;s=k; p-\u0026gt;s1=log10(u)*p-\u0026gt;s; x-\u0026gt;s1=log10(u)*x-\u0026gt;s; a=x; b=p; return; } ele s=x-\u0026gt;l?x-\u0026gt;l-\u0026gt;s:0,mid=(u+v)\u0026gt;\u0026gt;1; if (k\u0026lt;s){ split(x-\u0026gt;l,k,u,mid,a,b); p-\u0026gt;l=a; maintain(p); x-\u0026gt;l=b; maintain(x); a=p; b=x; } else{ split(x-\u0026gt;r,k-s,mid+1,v,a,b); x-\u0026gt;r=a; maintain(x); p-\u0026gt;r=b; maintain(p); a=x; b=p; } } inline void split(ele i){ if (S.find(i)!=S.end()) return; S.insert(i); auto it=S.find(i),it1=it,it2=it; --it1; ++it2; tg[*it]=tg[*it1]; if (tg[*it1]) split(T[*it1],*it-*it1,1,n,T[*it1],T[*it]); else split(T[*it1],*it2-*it,1,n,T[*it],T[*it1]); } int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); for (int i=0; i\u0026lt;n; ++i){ scanf(\u0026#34;%d\u0026#34;,a+i); S.insert(i); T[i]=upd(NULL,1,n,a[i]); tg[i]=1; s[i]=log10(a[i]); } for (int i=1; i\u0026lt;n; ++i) s[i]+=s[i-1]; s1=0; S.insert(n); bool flag=true; while (m--){ ele op,l,r,f; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;op,\u0026amp;l,\u0026amp;r); --l,--r; split(l); split(r+1); if (op==1){ flag=false; scanf(\u0026#34;%d\u0026#34;,\u0026amp;f); node *p=NULL; for (auto it=S.find(l); *it\u0026lt;=r;){ p=merge(p,T[*it]); S.erase(it++); } S.insert(l); T[l]=p; tg[l]=f; } else{ db tmp=0; if (flag) tmp=s[r]-s[l-1]; else for (auto it=S.find(l); *it\u0026lt;=r; ++it) tmp+=T[*it]-\u0026gt;s1; tmp=tmp-trunc(tmp); ele ans=exp(log(10)*tmp); printf(\u0026#34;%d\\n\u0026#34;,ans); } } return 0; } ","permalink":"https://seraphim.rocks/posts/loj6189/","tags":["题解","loj","ODT","线段树合并"],"title":"loj6189题解"},{"categories":null,"contents":"把所有向量组合成一个\\(n\\times d\\)的矩阵\\(A\\)，那么问题其实就是判断\\(AA^T=B\\)除了对角线上是否存在\\(0\\)（模\\(k\\)意义下）.\n先忽略对角线这个问题，判断\\(B\\)中是否存在\\(0\\)，如果\\(k=2\\)，其实就是要判断\\(B\\)是否为全\\(1\\)矩阵. 判断是否相等有一个套路，就是随机一个\\(1\\times n\\)的向量\\(X\\)，判断\\(XAA^T\\)是否等于\\(XB\\)，这样时间复杂度降至\\(\\mathcal O(nd)\\). 如果判断发现相等，错误率为\\(\\frac{1}{2}\\)，重复若干次即可让错误率足够小.\n下面考虑\\(k=3\\)的情况. 如果\\(B\\)中不存在\\(0\\)，\\(B\\)中的元素仍可能为\\(1\\)或\\(2\\). 定义\\(C _{i,j}=B _{i,j}^2\\)，那么如果\\(B\\)中不存在\\(0\\)，则\\(C\\)为全\\(1\\)矩阵，关键是表示出这个\\(C\\). 注意到\n\\[\\left(\\sum _{i=1}^da _ib _i\\right)^2=\\sum _{i=1}^d\\sum _{j=1}^da _ia _jb _ib _j \\]\n于是把输入的\\(d\\)维向量都变成\\(d^2\\)维的向量，就可以处理\\(k=3\\)的情况了.\n接下来处理对角线. 注意到我们可以直接在\\(\\mathcal O(nd)\\)的时间内把对角线计算出来，那么\\(XB\\)考虑对角线之后的值也可以高效算得.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int using namespace std; #define maxn 100010 #define maxd 110  namespace io{ static const ele size=1\u0026lt;\u0026lt;20; char buf[size],*s=buf,*t=buf; inline char gc(){ return s==t \u0026amp;\u0026amp; (t=(s=buf)+fread(buf,1,size,stdin)),s==t?EOF:*s++; } template\u0026lt;class I\u0026gt;inline void gi(I\u0026amp;a){ char c; while ((c=gc())\u0026lt;\u0026#39;0\u0026#39; || c\u0026gt;\u0026#39;9\u0026#39;); a=c-\u0026#39;0\u0026#39;; while ((c=gc())\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;9\u0026#39;) a=(a\u0026lt;\u0026lt;3)+(a\u0026lt;\u0026lt;1)+c-\u0026#39;0\u0026#39;; } } using io::gi; const ele mul[3][3]={{0,0,0},{0,1,2},{0,2,1}}; ele n,d,d1,k,a[maxn][maxd],b[maxn],c[10000],dg[maxn],dst[maxn],p[10000],q[10000]; inline ele A(ele i,ele j){ return k==2?a[i][j]:mul[a[i][p[j]]][a[i][q[j]]]; } inline ele\u0026amp; add(ele\u0026amp;a,ele b){ return a+b\u0026gt;=k?((a+=b)-=k):(a+=b); } int main(){ gi(n); gi(d); gi(k); d1=k==2?d:d*d; for (int i=0; i\u0026lt;n; ++i) for (int j=0; j\u0026lt;d; ++j) gi(a[i][j]),a[i][j]%=k; for (int i=0; i\u0026lt;d; ++i) for (int j=0; j\u0026lt;d; ++j) p[i*d+j]=i,q[i*d+j]=j; for (int i=0; i\u0026lt;n; ++i){ dg[i]=0; for (int j=0; j\u0026lt;d1; ++j) add(dg[i],A(i,j)); } ele K=10; while (K--){ ele s=0; for (int i=0; i\u0026lt;n; ++i){ b[i]=rand()%k; add(s,b[i]); } for (int i=0; i\u0026lt;n; ++i) dst[i]=s,add(dst[i],mul[b[i]][dg[i]]-b[i]+k); memset(c,0,sizeof(c)); for (int j=0; j\u0026lt;n; ++j) for (int i=0; i\u0026lt;d1; ++i) add(c[i],mul[b[j]][A(j,i)]); memset(b,0,sizeof(b)); for (int i=0; i\u0026lt;n; ++i) for (int j=0; j\u0026lt;d1; ++j) add(b[i],mul[c[j]][A(i,j)]); for (int i=0; i\u0026lt;n; ++i) if (b[i]!=dst[i]){ for (int j=0; j\u0026lt;n; ++j){ if (i==j) continue; ele s1=0; for (int r=0; r\u0026lt;d; ++r) add(s1,mul[a[i][r]][a[j][r]]); if (!s1){ printf(\u0026#34;%d %d\\n\u0026#34;,min(i,j)+1,max(i,j)+1); return 0; } } } } puts(\u0026#34;-1 -1\u0026#34;); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2664/","tags":["题解","loj","线性代数","随机化"],"title":"loj2664题解"},{"categories":null,"contents":"一开始居然脑子短路没有想到斜率优化……以后看到这种感觉跟凸包有关系，要求最值/要最优化的问题，可以考虑写个dp方程出来看看能不能斜率优化.\n首先考虑链上，没有\\(l _v\\)的限制的情况，可以写出dp方程\n\\[ 这显然可以斜率优化，把$j$看成点$(d _j,\\textrm{res} _j)$，那么使得答案最优的转移点一定在凸包上. 接下来考虑$l _v$的限制. 这个限制导致了一个问题，就是我们寻找转移点的时候，要在某个区间$[k,i)$上找，而不是在$[0,i)$上. 用二进制分组可以解决这个问题. 接下来考虑放到树上. 树造成了一个新的问题，如果我们直接做斜率优化的树形dp，就要支持在末端加入或者删除一个点，并维护凸包. 二进制分组理论上是只能加点的，否则摊还分析就会失效. 这里有一个简单的方法：只有在分裂了一个很大的块的时候，才会有很大的时间开销，因此我们可以随机地加入一些无用的点，就比较难卡掉了. 出题人好像没有考虑过这个算法，所以直接暴力删除也能过，还更快.  其实还有一些更靠谱的做法，比方说二进制分组靠谱的删除方法，类似替罪羊树的懒惰删除，但是我不想写. 或者树上问题转为链上问题的经典思路树剖，即在重链上二进制分组，重链之间直接暴力. 或者带根的点分治，晚点再研究. 有一个坑点是构建凸包的时候直接做叉积会爆long long 代码： ```cpp #include  #include  #include  #include  #define ele long long #define db double using namespace std; #define maxn 400010 const ele M=1v[size]; inline void addedge(ele u,ele v){ edge *p=ecnt++; p-v=v; p-nxt=h[u]; h[u]=p; } inline void build(vector\u0026v,ele l,ele r){ v.clear(); for (int i=l; i1 \u0026\u0026 test(v[v.size()-1]-v[v.size()-2],seq[i]-v[v.size()-1])=1,L\u0026v,ele d,ele p,ele q){ if (!v.size()) return INF; ele L=-1,R=v.size()-1; while (R-L1){ ele mid=(L+R)1; if (calc(v[mid],d,p,q)=calc(v[mid+1],d,p,q)) L=mid; else R=mid; } return calc(v[R],d,p,q); } inline ele qry(ele l,ele r,ele d,ele p,ele q){ ele ans=1e18; for (l=l+M-1,r=r+M+1; l^r^1; l=1,r=1){ if (~l\u00261) ans=min(ans,qry(v[l^1],d,p,q)); if (r\u00261) ans=min(ans,qry(v[r^1],d,p,q)); } return ans; } void dfs(ele i){ if (i){ ele L=-1,R=top-1; while (R-L1){ ele mid=(L+R)1; if (d[i]-d[stk[mid]]nxt) d[j-v]=d[i]+s[j-v],dfs(j-v); --top; do{ pop(); } while (seq[tot].x!=d[i] || seq[tot].y!=res[i]); } int main(){ scanf(\"%lld%lld\",\u0026n,\u0026ty); ecnt=ep; memset(h,0,sizeof(h)); for (int i=1; i","permalink":"https://seraphim.rocks/posts/loj2249/","tags":["题解","loj","DP","斜率优化","凸包","二进制分组"],"title":"loj2249题解"},{"categories":null,"contents":"容易发现答案一定在凸包上，询问的\\(y\\lt 0\\)则在上凸壳，否则在下凸壳.\n容易发现\\(A\\cup B\\)凸包上的点一定在\\(A\\)或\\(B\\)的凸包上，所以可以考虑用线段树来维护，每个节点保存对应区间的凸包，每个询问查询\\(\\mathcal O(\\log n)\\)个线段树上的节点.\n但是这里有一个问题，凸包无法高效合并，插入也很麻烦，但是如果知道最后的点集的话离线构建是非常容易的. 这种情况一般可以考虑二进制分组. 对于本题，把二进制分组放到线段树上，也就是说当一个节点对应的区间被填满的时候，再构建这个节点的凸包.\n有一个细节一定要记住：求凸壳的时候两维坐标都要排序：从大到小和从小到大都没问题，两个维度顺序相反也没问题，但是一定要排序. 我也不是很清楚为什么. 以后遇到给struct排序的情况，最好是给每一个属性都定一个顺序.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#define ele long long using namespace std; #define maxn 400010 const ele M=1\u0026lt;\u0026lt;19; const ele size=M\u0026lt;\u0026lt;1; struct pt{ ele x,y; inline bool operator\u0026lt;(pt b)const{ return x!=b.x?x\u0026lt;b.x:y\u0026lt;b.y; } }p[maxn]; inline pt operator+(pt a,pt b){ return (pt){a.x+b.x,a.y+b.y}; } inline pt operator-(pt a,pt b){ return (pt){a.x-b.x,a.y-b.y}; } inline ele dot(pt a,pt b){ return a.x*b.x+a.y*b.y; } inline ele cross(pt a,pt b){ return a.x*b.y-a.y*b.x; } ele n,lastans,a[size]; char ty[10]; vector\u0026lt;pt\u0026gt; v1[size],v2[size]; inline ele decode(ele x){ return x^(lastans\u0026amp;0x7fffffff); } inline void maintain(ele i){ a[i]=a[i\u0026lt;\u0026lt;1]+a[i\u0026lt;\u0026lt;1|1]; } inline void build(vector\u0026lt;pt\u0026gt;\u0026amp;v1,vector\u0026lt;pt\u0026gt;\u0026amp;v2,ele l,ele r){ ele top=0; static pt q[maxn]; memcpy(q,p+l,sizeof(pt)*(r-l+1)); sort(q,q+r-l+1); for (int i=l; i\u0026lt;=r; ++i){ while (top\u0026gt;1 \u0026amp;\u0026amp; cross(v1[top-1]-v1[top-2],q[i-l]-v1[top-1])\u0026gt;=0) --top,v1.pop_back(); v1.push_back(q[i-l]); ++top; } top=0; for (int i=l; i\u0026lt;=r; ++i){ while (top\u0026gt;1 \u0026amp;\u0026amp; cross(v2[top-1]-v2[top-2],q[i-l]-v2[top-1])\u0026lt;=0) --top,v2.pop_back(); v2.push_back(q[i-l]); ++top; } } inline void upd(ele i){ ele L=1,j=i; i+=M; for (; i; i\u0026gt;\u0026gt;=1,L\u0026lt;\u0026lt;=1){ ++a[i]; if (a[i]==L) build(v1[i],v2[i],j-L+1,j); } } inline ele qry(vector\u0026lt;pt\u0026gt;\u0026amp;v,pt p){ ele L=-1,R=v.size()-1; while (R-L\u0026gt;1){ ele mid=(L+R)\u0026gt;\u0026gt;1; if (dot(v[mid],p)\u0026lt;=dot(v[mid+1],p)) L=mid; else R=mid; } return dot(v[R],p); } inline ele qry(ele l,ele r,pt p){ ele ans=-1e18; for (l=l+M-1,r=r+M+1; l^r^1; l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1){ if (~l\u0026amp;1) ans=max(ans,p.y\u0026gt;0?qry(v1[l^1],p):qry(v2[l^1],p)); if (r\u0026amp;1) ans=max(ans,p.y\u0026gt;0?qry(v1[r^1],p):qry(v2[r^1],p)); } return ans; } int main(){ scanf(\u0026#34;%lld%s\u0026#34;,\u0026amp;n,ty); memset(a,0,sizeof(a)); lastans=0; ele i=1; while (n--){ char op[5]; ele x,y,l,r; scanf(\u0026#34;%s%lld%lld\u0026#34;,op,\u0026amp;x,\u0026amp;y); if (ty[0]!=\u0026#39;E\u0026#39;) x=decode(x),y=decode(y); if (op[0]==\u0026#39;A\u0026#39;){ p[i]=(pt){x,y}; upd(i); ++i; } else{ scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;l,\u0026amp;r); if (ty[0]!=\u0026#39;E\u0026#39;) l=decode(l),r=decode(r); printf(\u0026#34;%lld\\n\u0026#34;,lastans=qry(l,r,(pt){x,y})); } } return 0; } ","permalink":"https://seraphim.rocks/posts/bzoj3533/","tags":["题解","loj","凸包","二进制分组"],"title":"bzoj3533题解"},{"categories":null,"contents":"vfk说分不清noi2014和noip2014果然是有道理的……\n因为要求字典序最小，可以直接从小到大枚举每个数，如果能加进字典序中，就贪心地加进去，正确性显然.\n现在问题是怎么判断一个数能否加在当前的字典序里面. 注意到一条路径合法等价于它的横坐标和纵坐标均单调不减，维护\\(c _i\\)和\\(d _i\\)表示当前已经加进去的点中，横坐标为\\(i\\)的点的最小值和最大值. 每次加入一个点，先用zkw线段树找出小于它的最大的横坐标和大于它的最小的横坐标，假设为\\(j\\)和\\(k\\)，判断它的纵坐标是否在\\(d _j\\)和\\(c _k\\)之间即可.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; #define maxn 5010 const ele M=1\u0026lt;\u0026lt;13; const ele size=M\u0026lt;\u0026lt;1; ele n,m,Q,x0,A,B,C,D,a[maxn*maxn],p[maxn*maxn],c[maxn],d[maxn],ans[maxn+maxn]; bool b[size]; inline void maintain(ele i){ b[i]=b[i\u0026lt;\u0026lt;1]|b[i\u0026lt;\u0026lt;1|1]; } inline void upd(ele i){ i+=M; b[i]=true; while (i\u0026gt;1) maintain(i\u0026gt;\u0026gt;=1); } ele _getl(ele i){ return i\u0026gt;=M?i-M:(b[i\u0026lt;\u0026lt;1|1]?_getl(i\u0026lt;\u0026lt;1|1):_getl(i\u0026lt;\u0026lt;1)); } ele getl(ele i){ return (i\u0026amp;1) \u0026amp;\u0026amp; b[i^1]?_getl(i^1):getl(i\u0026gt;\u0026gt;1); } ele _getr(ele i){ return i\u0026gt;=M?i-M:(b[i\u0026lt;\u0026lt;1]?_getr(i\u0026lt;\u0026lt;1):_getr(i\u0026lt;\u0026lt;1|1)); } ele getr(ele i){ return (~i\u0026amp;1) \u0026amp;\u0026amp; b[i^1]?_getr(i^1):getr(i\u0026gt;\u0026gt;1); } inline bool test(ele i){ ele x=p[i]/m+1,y=p[i]%m+1; ele j=getl(x+M),k=getr(x+M); return d[j]\u0026lt;=y \u0026amp;\u0026amp; y\u0026lt;=c[k]; } int main(){ scanf(\u0026#34;%d%d%d%d%d%d%d%d\u0026#34;,\u0026amp;x0,\u0026amp;A,\u0026amp;B,\u0026amp;C,\u0026amp;D,\u0026amp;n,\u0026amp;m,\u0026amp;Q); for (int i=0; i\u0026lt;n*m; ++i) a[i]=i; for (int i=1; i\u0026lt;=n*m; ++i){ x0=((ll)A*x0%D*x0%D+(ll)B*x0%D+C)%D; swap(a[i-1],a[x0%i]); } while (Q--){ ele u,v; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;u,\u0026amp;v); swap(a[u-1],a[v-1]); } for (int i=0; i\u0026lt;n*m; ++i) p[a[i]]=i; memset(b,0,sizeof(b)); b[0+M]=b[n+1+M]=true; for (int i=M-1; i; --i) maintain(i); memset(c,-1,sizeof(c)); memset(d,-1,sizeof(d)); c[0]=d[0]=0; c[n+1]=d[n+1]=m+1; ele cnt=0; for (int i=0; i\u0026lt;n*m \u0026amp;\u0026amp; cnt\u0026lt;n+m-1; ++i) if (test(i)){ ans[cnt++]=i; ele x=p[i]/m+1,y=p[i]%m+1; if (~c[x]) c[x]=min(c[x],y),d[x]=max(d[x],y); else c[x]=d[x]=y; upd(x); } for (int i=0; i\u0026lt;n+m-1; ++i) printf(i?\u0026#34; %d\u0026#34;:\u0026#34;%d\u0026#34;,ans[i]+1); puts(\u0026#34;\u0026#34;); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2248/","tags":["题解","loj","贪心","智力康复"],"title":"loj2248题解"},{"categories":null,"contents":"首先注意到选择了一个数就是选择了它的所有素因子，而不超过\\(\\sqrt{n}\\)的素数至多只有8个，可以考虑状压. 超过的那些我们先不管.我一开始想的是枚举每个素数被分在哪边，这样是\\(3^8\\)的，但是我没想出来. 事实上完全可以暴力一点到\\(4^8\\)，这样可以把状态表示为\\((s _1,s _2)\\)，即第一个人选了集合\\(s _1\\)，第二个人选了集合\\(s _2\\)（可以有交），最后把所有\\(s _1\\cap s _2=\\emptyset\\)的状态的答案加起来即可.\n现在考虑大于\\(\\sqrt{n}\\)的素因子，每个数最多只有一个，因此我们可以把数按照这个素因子来分类. 我一开始的想法是对每一类分别dp再合并起来，但是发现不方便合并. 很多这种不方便合并的情况，可以考虑在前一个的基础上去dp下一个.\n具体来讲，让\\(f _{j,k}\\)表示之前dp出来的结果，dp出\\(g _{j,k}\\)和\\(h _{j,k}\\)分别表示只有第一/二个人能选当前这一类，最后两人选的集合为\\(j,k\\)的方案数，最后再让\\(f _{j,k}=g _{j,k}+h _{j,k}-f _{j,k}\\)，最后一项是因为两个人都不选这一类的情况被算了两次.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#define ele int using namespace std; #define maxn 510 #define K 8 #define maxs (1\u0026lt;\u0026lt;8) const ele p[]={2,3,5,7,11,13,17,19}; ele n,P,f[maxs][maxs],g[maxs][maxs],h[maxs][maxs],t1[maxs][maxs],t2[maxs][maxs]; vector\u0026lt;ele\u0026gt; v[maxn]; inline ele getv(ele x,ele i){ return (x\u0026gt;\u0026gt;i)\u0026amp;1; } inline ele\u0026amp; setv(ele\u0026amp;x,ele i,ele k){ x=x\u0026amp;~(1\u0026lt;\u0026lt;i); x=x|(k\u0026lt;\u0026lt;i); return x; } inline ele\u0026amp; add(ele\u0026amp;a,ele b){ return a+b\u0026gt;=P?((a+=b)-=P):(a+=b); } int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;P); for (int i=2; i\u0026lt;=n; ++i){ ele tmp=i,s=0; for (int j=0; j\u0026lt;K; ++j) if (tmp%p[j]==0){ setv(s,j,1); while (tmp%p[j]==0) tmp/=p[j]; } v[tmp].push_back(s); } memset(f,0,sizeof(f)); f[0][0]=1; for (int i=0; i\u0026lt;v[1].size(); ++i){ memcpy(t1,f,sizeof(f)); for (int j=0; j\u0026lt;maxs; ++j) for (int k=0; k\u0026lt;maxs; ++k) if (f[j][k]){ add(t1[j|v[1][i]][k],f[j][k]); add(t1[j][k|v[1][i]],f[j][k]); } memcpy(f,t1,sizeof(f)); } for (int i=2; i\u0026lt;=n; ++i) if (v[i].size()){ memcpy(g,f,sizeof(g)); memcpy(h,f,sizeof(h)); for (int r=0; r\u0026lt;v[i].size(); ++r){ memcpy(t1,g,sizeof(g)); memcpy(t2,h,sizeof(h)); for (int j=0; j\u0026lt;maxs; ++j) for (int k=0; k\u0026lt;maxs; ++k){ add(t1[j|v[i][r]][k],g[j][k]); add(t2[j][k|v[i][r]],h[j][k]); } memcpy(g,t1,sizeof(g)); memcpy(h,t2,sizeof(h)); } for (int j=0; j\u0026lt;maxs; ++j) for (int k=0; k\u0026lt;maxs; ++k){ f[j][k]=P-f[j][k]; add(add(f[j][k],g[j][k]),h[j][k]); } } ele ans=0; for (int j=0; j\u0026lt;maxs; ++j) for (int k=0; k\u0026lt;maxs; ++k) if (!(j\u0026amp;k)) add(ans,f[j][k]); printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2131/","tags":["题解","loj","DP","状态压缩","数论"],"title":"loj2131题解"},{"categories":null,"contents":"挺优美的一道数论题. 当然也有可能是我太菜了.\n首先显然是考虑只计算既约分数来避免算重，即只计算\\(x\\perp y\\). 考虑\\(k=10\\)的时候，\\(\\frac{x}{y}\\)符合题目条件当且仅当\\(y\\)没有因数\\(2,5\\). 容易证明对于所有情况，\\(\\frac{x}{y}\\)符合题目条件等价于\\(y\\perp k\\). 所以我们要计算的其实就是\n\\[ 一开始我很傻地把两个中括号都拆开了，其实应该先只拆一个观望一下. 因为$[x\\perp y]$这一项复杂一些，所以考虑先拆这个（其实还是在瞎猜），得到 $$\\begin{aligned}\u0026\\sum _{y=1}^m[y\\perp k]\\sum _{x=1}^n\\sum _{d|x,~d|y}\\mu(d)\\\\=\u0026\\sum _{y=1}^m[y\\perp k]\\sum _{d|y}^n\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\\\=\u0026\\sum _{d=1}^n\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\sum _{y=1}^{\\lfloor m/d\\rfloor}[dy\\perp k]\\\\=\u0026\\sum _{d=1}^n[d\\perp k]\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor\\sum _{y=1}^{\\lfloor m/d\\rfloor}[y\\perp k]\\end{aligned}$$ 定义$f(n)=\\sum _{y=1}^m[y\\perp k]$，那么有$f(km+r)=mf(k)+f(r)~(0\\le r\\lt k)$，所以预处理$f(1),f(2),\\ldots,f(k)$就可以$\\mathcal O(1)$计算了. 之前的式子化为 $$\\sum _{d=1}^n[d\\perp k]\\mu(d)\\left\\lfloor\\frac{n}{d}\\right\\rfloor f(\\left\\lfloor\\frac{m}{d}\\right\\rfloor)$$ 对这个式子整除分块，于是我们需要快速计算 $$f(n,k)=\\sum _{d=1}^n[d\\perp k]\\mu(d)$$ 如果没有$[d\\perp k]$，那就是一个简单的杜教筛，现在加上这一项，它还是积性函数没关系就可以考虑从总和里面去掉不互质的，设$k=p^rq$，其中$p$为素数，$p\\perp q$，那么有 $$\\begin{aligned}f(n,k)=\u0026f(n,q)-\\sum _{y=1}^{\\lfloor n/p\\rfloor}[py\\perp q]\\mu(py)\\\\=\u0026f(n,q)-\\sum _{y=1}^{\\lfloor n/p\\rfloor}[y\\perp q]\\mu(py)\\\\=\u0026f(n,q)-\\sum _{y=1}^{\\lfloor n/p\\rfloor}[y\\perp q][y\\perp p]\\mu(p)\\mu(y)\\\\=\u0026f(n,q)+\\sum _{y=1}^{\\lfloor n/p\\rfloor}[y\\perp k]\\mu(y)\\\\=\u0026f(n,q)+f(\\left\\lfloor\\frac{n}{p}\\right\\rfloor,k)\\end{aligned}$$ 然后注意到$f(n,1)$可以直接杜教筛，这道题就可以做了. 代码： ```cpp #include  #include  #include  #include  #define ele long long using namespace std; #define maxn 1000010 #define maxk 2010 templatestruct hashmap{ static const ele R=8000009; T1 a[R]; T2 b[R]; bool c[R]; hashmap(){ memset(c,0,sizeof(c)); } inline ele find(T1 x){ ele i=x%R; for (; c[i] \u0026\u0026 a[i]!=x; (i+=1)%=R); return i; } inline bool test(T1 x){ return c[find(x)]; } inline T2\u0026 operator[](T1 x){ ele i=find(x); !c[i] \u0026\u0026 (c[i]=true,a[i]=x,b[i]=0); return b[i]; } }; ele n,m,k,S,f[maxk],pcnt,plst[maxn],mu[maxn],qcnt,q[maxk]; bool flag[maxn]; hashmap g; ele gcd(ele a,ele b){ return b?gcd(b,a%b):a; } ele calc(ele n){ if (n1; ){ ele d1=max(1ll,n/(n/d+1)); g[n]-=calc(n/d)*(d-d1); d=d1; } return g[n]; } inline ele calcf(ele n){ return f[k]*(n/k)+f[n%k]; } ele calcg(ele n,ele i){ if (!i) return calc(n); if (!n) return 0; if (n==1) return 1; return calcg(n,i-1)+calcg(n/q[i-1],i); } int main(){ scanf(\"%lld%lld%lld\",\u0026n,\u0026m,\u0026k); S=exp(log(n)/3*2); f[0]=0; for (int i=1; i1 \u0026\u0026 (q[qcnt++]=tmp); ele ans=0; for (ele d=min(n,m); d; ){ ele d1=n/(n/d+1),d2=m/(m/d+1); d1=max(d1,d2); ans+=calcf(m/d)*(n/d)*(calcg(d,qcnt)-calcg(d1,qcnt)); d=d1; } printf(\"%lld\\n\",ans); return 0; } ```\\]\n","permalink":"https://seraphim.rocks/posts/loj2085/","tags":["题解","loj","数论"],"title":"loj2085题解"},{"categories":null,"contents":"这题面写得有毒……应该理解为对于第\\(i\\)种蔬菜，有\\(x _i\\)个单位只能在第一天卖，有\\(x _i\\)个单位只能在第二天结束前卖，以此类推. 也就是说，说你把当天结束本来要变质的蔬菜卖了，那天就不会有蔬菜变质了.\n那么我们就有一个朴素的贪心策略：每种蔬菜尽量等到它快要变质了才卖，也就是时间上从后往前贪心. 如果有两种蔬菜要抢夺某一天出售的机会，那肯定是从贵的开始贪心.\n这个算法看上去很正确，但是它没有办法处理\\(s _i\\). 方法是把每种蔬菜拆成两部分：\\((a _i,c _i-1)\\)和\\((a _i+s _i,1)\\)，后者的过期时间即为该种蔬菜最晚的销售时间，然后把所有这些东西按价格排序，每种价格从后往前贪心就可以了. 每种蔬菜在某一天可以销售的量等于贪心到那个时候还剩下的量减去那天之前变质的量. 要用并查集或者set来查询上一个还可以销售的时间.\n但是这样只能处理一个询问. 用反证法容易证明\\(k\\)天的答案一定是\\(k+1\\)天的答案的子集，而在较后时间出售的蔬菜在较前的时间显然也可以出售，那么只需要对\\(\\max p _i\\)算出答案，然后每天去掉最廉价的若干单位蔬菜就可以了. 每天需要去掉的量其实就是，把蔬菜的销售尽量往前放之后，当天销售的量.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#define ele long long using namespace std; #define maxn 200010 const ele INF=1e18; struct st{ ele a,c,d,x; inline bool operator\u0026lt;(st b)const{ return a!=b.a?a\u0026lt;b.a:d\u0026lt;b.d; } }b[maxn]; ele n,m,K,mx,p[maxn],a[maxn],s[maxn],c[maxn],x[maxn],u[maxn],prv[maxn],r[maxn],res[maxn],f[10000010]; priority_queue\u0026lt;st\u0026gt; Q; ele getf(ele *u,ele x){ return u[x]\u0026lt;0?x:(u[x]=getf(u,u[x])); } inline void uni(ele x,ele y){ ele a=getf(u,x),b=getf(u,y); if (a!=b) u[a]=b; } int main(){ scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;K); for (int i=0; i\u0026lt;n; ++i) scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;,a+i,s+i,c+i,x+i); mx=0; for (int i=0; i\u0026lt;K; ++i) scanf(\u0026#34;%lld\u0026#34;,p+i),mx=max(mx,p[i]); for (int i=0; i\u0026lt;n; ++i) if (x[i]){ ele d=(c[i]-1)/x[i]+1; b[i\u0026lt;\u0026lt;1]=(st){a[i]+s[i],1,d-1,0}; b[i\u0026lt;\u0026lt;1|1]=(st){a[i],c[i]-1,d-1,x[i]}; } else{ b[i\u0026lt;\u0026lt;1]=(st){a[i]+s[i],1,mx-1,0}; b[i\u0026lt;\u0026lt;1|1]=(st){a[i],c[i]-1,mx-1,0}; } for (int i=0; i\u0026lt;n*2; ++i) if (b[i].d\u0026gt;=0 \u0026amp;\u0026amp; b[i].c) Q.push(b[i]); memset(u,-1,sizeof(u)); for (int i=0; i\u0026lt;mx; ++i) prv[i]=i-1,r[i]=m; prv[0]=mx; u[mx]=-1; ele ans=0,cnt=0; while (Q.size() \u0026amp;\u0026amp; getf(u,mx-1)!=mx){ st k=Q.top(); Q.pop(); ele d=getf(u,min(k.d,mx-1)); while (d\u0026lt;mx \u0026amp;\u0026amp; k.c){ ele tmp=min(k.c-k.x*d,r[d]); k.c-=tmp; r[d]-=tmp; ans+=k.a*tmp; for (int j=0; j\u0026lt;tmp; ++j) f[cnt++]=-k.a; if (!r[d]) uni(d,prv[d]); d=getf(u,prv[d]); } } sort(f,f+cnt); res[mx]=ans; ele tot=0; for (int i=0; i\u0026lt;mx; ++i) tot+=m-r[i]; memset(r,0,sizeof(r)); for (int i=0; i\u0026lt;mx; ++i) r[i]=min(m,tot),tot-=r[i]; for (int i=mx-1; ~i; --i){ res[i]=res[i+1]; for (int j=0; j\u0026lt;r[i]; ++j) res[i]-=-f[--cnt]; } for (int i=0; i\u0026lt;K; ++i) printf(\u0026#34;%lld\\n\u0026#34;,res[p[i]]); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2306/","tags":["题解","loj","贪心"],"title":"loj2306题解"},{"categories":null,"contents":"首先恰好为\\(k\\)不好处理，显然要转化为\\(\\le k\\)的概率减去\\(\\le k-1\\)的概率.\n看上去就是个dp，让\\(f _i\\)表示共\\(i\\)列，安全泳池面积\\(\\le k\\)的概率，考虑怎么递推. 假设最底下一行有一个格子是危险的，那么显然这一列两边互不干扰可以分开计算. 但是这里有一个问题，底下一行可能没有危险的格子. 于是我们把状态改为\\(f _{i,j}\\)表示共\\(i\\)列，下面\\(j\\)行均安全，第\\(j+1\\)行至少有一个危险的格子，且安全泳池面积\\(\\le k\\)的概率. 记\\(g _{i,j}=\\sum _{w\\ge j}f _{i,w}\\)，即共\\(i\\)列，下面\\(j\\)行均安全，且安全泳池面积\\(\\le k\\)的概率.\n那么我们就可以枚举第\\(j+1\\)行最后一个危险格子的位置，得到递推式\n\\[f _{i,j}=\\sum _{r\\lt i,~r(j+1)\\le k}g _{r,j+1}g _{i-r-1,j}q^j(1-q) \\]\n注意到\\(\\forall ijk,~f _{i,j}=0\\)，直接dp就可以得到70分.\n考虑怎么拿剩下的30分. 显然当\\(i\\gt k\\)时只需要考虑\\(f _{i,0}\\)，而且此时\\(f _{i,0}=g _{i,0}\\). 而\\(r\\le\\frac{k}{j+1}\\le k\\)，所以当\\(i\\ge 2k+2\\)时，递推式可以写成\n\\[g _{i,0}=\\sum _{r=0}^k(1-q)g _{r,1}g _{i-r-1,0} \\]\n这是一个常系数线性齐次递推式，前面暴力递推到\\(i=2k+1\\)，后面的用特征多项式可以做到\\(\\mathcal O(k^2\\log n)\\).\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; #define maxk 4010 #define MOD 998244353 ele n,K,x,y,q,f[maxk][maxk]; inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } inline void mul(ele K,ele *a,ele *b){ static ele c[maxk]; memset(c,0,sizeof(c)); for (int i=0; i\u0026lt;=K; ++i) for (int j=0; j\u0026lt;=K; ++j) (c[i+j]+=(ll)a[i]*b[j]%MOD)%=MOD; for (int i=K*2; i\u0026gt;K; --i) for (int j=0; j\u0026lt;=K; ++j) (c[i-j-1]+=(ll)c[i]*f[j][1]%MOD*(MOD+1-q)%MOD)%=MOD; memcpy(a,c,sizeof(ele)*(K+1)); } inline ele calc(ele K){ for (int i=0; i\u0026lt;=K+1; ++i) f[0][i]=1; for (int i=1; i\u0026lt;=n \u0026amp;\u0026amp; i\u0026lt;=K*2+1; ++i){ for (int j=0; i*j\u0026lt;=K; ++j){ f[i][j]=0; ele tmp=(ll)pw(q,j)*(MOD+1-q)%MOD; for (int r=0; r\u0026lt;i \u0026amp;\u0026amp; r*(j+1)\u0026lt;=K; ++r){ ele t1=(ll)f[r][j+1]*tmp%MOD*f[i-r-1][j]%MOD; (f[i][j]+=t1)%=MOD; } } for (int j=K/i-1; ~j; --j) (f[i][j]+=f[i][j+1])%=MOD; } if (n\u0026lt;=K*2+1) return f[n][0]; static ele a[maxk],b[maxk]; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); a[0]=1; b[1]=1; for (ele n1=n-K-1; n1; n1\u0026gt;\u0026gt;=1,mul(K,b,b)) if (n1\u0026amp;1) mul(K,a,b); ele ans=0; for (int i=0; i\u0026lt;=K; ++i) (ans+=(ll)a[i]*f[K+1+i][0]%MOD)%=MOD; return ans; } int main(){ scanf(\u0026#34;%d%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;K,\u0026amp;x,\u0026amp;y); q=(ll)x*pw(y,MOD-2)%MOD; ele t1=calc(K); ele t2=calc(K-1); (t1+=MOD-t2)%=MOD; printf(\u0026#34;%d\\n\u0026#34;,t1); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2304/","tags":["题解","loj","DP","线性代数","多项式"],"title":"loj2304题解"},{"categories":null,"contents":"我怕不是在做noip题……\n注意到\\(k\\le 50\\)，询问会涉及到的向后\\(k\\)数字串个数为\\(\\mathcal O(nk)\\)，可以考虑直接把所有这些串的hash值存到hash表里面，进行修改操作的时候受影响的串只有\\(\\mathcal O(k^2)\\)个，暴力维护即可.\n卡常死活卡不过去，profile了一发，发现性能瓶颈是unordered_map，改成手写hash表直接3.4s-\u0026gt;0.7s. 以后能手写的时候还是手写吧.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; namespace io{ const ele size=1\u0026lt;\u0026lt;20; char buf[size],*s=buf,*t=buf; inline char gc(){ return s==t \u0026amp;\u0026amp; ((t=(s=buf)+fread(buf,1,size,stdin)),s==t)?EOF:*s++; } template\u0026lt;class I\u0026gt;inline void gi(I\u0026amp;a){ char c; while ((c=gc())\u0026lt;\u0026#39;0\u0026#39; || c\u0026gt;\u0026#39;9\u0026#39;); a=c-\u0026#39;0\u0026#39;; while ((c=gc())\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;9\u0026#39;) a=(a\u0026lt;\u0026lt;3)+(a\u0026lt;\u0026lt;1)+c-\u0026#39;0\u0026#39;; } inline void gs(char *s){ char c; while ((c=gc())\u0026lt;\u0026#39;0\u0026#39; || c\u0026gt;\u0026#39;9\u0026#39;); *s++=c; while ((c=gc())\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;9\u0026#39;) *s++=c; *s=0; } char obuf[size],*os=obuf,*ot=obuf; inline bool flush(){ fwrite(obuf,1,ot-os,stdout); os=ot=obuf; return true; } inline void pc(char c){ ot==obuf+size \u0026amp;\u0026amp; flush(),*ot++=c; } template\u0026lt;class I\u0026gt;inline void pi(I x){ if (!x) pc(\u0026#39;0\u0026#39;); else{ char s[20],cnt=0; while (x) s[cnt++]=x%10+\u0026#39;0\u0026#39;,x/=10; while (cnt) pc(s[--cnt]); } } } using io::gc; using io::gi; using io::gs; using io::pc; using io::pi; struct hashmap{ const static ele R=8000009; ll a[R]; ele b[R]; bool c[R]; hashmap(){ memset(c,0,sizeof(c)); } inline ele find(ll x){ ele i=x%R; for (; c[i] \u0026amp;\u0026amp; a[i]!=x; (i+=1)%=R); !c[i] \u0026amp;\u0026amp; (c[i]=true,a[i]=x,b[i]=0); return i; } inline ele\u0026amp; operator[](ll i){ return b[find(i)]; } }; #define maxn 200010 #define maxL 10000010 #define MOD 998244353 const ll seed=233; const ll p[]={29,30}; const ll P[]={(1\u0026lt;\u0026lt;p[0])-1,(1\u0026lt;\u0026lt;p[1])-1}; ele n,m,K,a[maxn],prv[maxn],nxt[maxn]; char s[maxL]; ll h[2][maxL],xl[2][55]; hashmap mp; template\u0026lt;class I\u0026gt;inline I _mod(I x,ele i){ return (x=(x\u0026gt;\u0026gt;p[i])+(x\u0026amp;P[i]))\u0026gt;=P[i]?x-P[i]:x; } inline void upd(ele u,ele v,ele delta){ ll t1=0,t2=0; for (int i=1; i\u0026lt;=K \u0026amp;\u0026amp; ~u; ++i,u=prv[u]){ t1*=seed; t1+=a[u]; t1=_mod(t1,0); t2*=seed; t2+=a[u]; t2=_mod(t2,1); ll t3=t1,t4=t2; ele w=v; for (int j=1; i+j\u0026lt;=K \u0026amp;\u0026amp; ~w; ++j,w=nxt[w]){ t3+=xl[0][i+j-1]*a[w]; t3=_mod(t3,0); t4+=xl[1][i+j-1]*a[w]; t4=_mod(t4,1); mp[t3+(t4\u0026lt;\u0026lt;30)]+=delta; } } } int main(){ gi(n); gi(m); K=m\u0026gt;300000?1:50; for (int i=0; i\u0026lt;n; ++i) gi(a[i]),++mp[(ll)a[i]+((ll)a[i]\u0026lt;\u0026lt;30)]; for (int j=0; j\u0026lt;2; ++j){ xl[j][0]=1; for (int i=1; i\u0026lt;=K; ++i) xl[j][i]=_mod(xl[j][i-1]*seed,j); } memset(prv,-1,sizeof(prv)); memset(nxt,-1,sizeof(nxt)); while (m--){ ele op,u,v; gi(op); if (op==1){ gi(u); gi(v); --u,--v; nxt[u]=v; prv[v]=u; upd(u,v,1); } else if (op==2){ gi(u); --u; v=nxt[u]; nxt[u]=prv[v]=-1; upd(u,v,-1); } else{ gs(s); gi(u); ele L=strlen(s); for (int j=0; j\u0026lt;2; ++j){ h[j][L]=0; for (int i=L-1; ~i; --i) h[j][i]=_mod(h[j][i+1]*seed+s[i]-\u0026#39;0\u0026#39;,j); } ele ans=1; for (int i=0; i+u\u0026lt;=L; ++i){ ll t1=_mod(h[0][i]+P[0]*P[0]-h[0][i+u]*xl[0][u],0); ll t2=_mod(h[1][i]+P[1]*P[1]-h[1][i+u]*xl[1][u],1); ll tmp=t1+(t2\u0026lt;\u0026lt;30); ans=(ll)ans*mp[tmp]%MOD; } pi(ans); pc(\u0026#39;\\n\u0026#39;); } } io::flush(); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2303/","tags":["题解","loj","字符串hash","hash表"],"title":"loj2303题解"},{"categories":null,"contents":"看到题目很容易想到压位+线段树，但是因为我太懒了这不太好写，我上网查了查发现了另一个很有意思的做法.\n这道题的难点在于处理进位和退位，更准确地说应该是处理退位，因为如果只有进位的话，可以暴力处理，进位的次数是摊还\\(\\mathcal O(1)\\)的. 那么我们可以把正的数和负的数分开加起来，假设和分别为\\(s _1\\)和\\(s _2\\)，每次询问就是要求\\(s _1-s _2\\)第\\(k\\)位上的数.\n为了求这个，我们需要知道做减法的时候在第\\(k\\)位上是否出现了退位，判断方法很简单，只需要比较两个数最低的\\(k-1\\)位的大小即可. 用zkw维护\\(s _1\\)异或\\(s _2\\)，找出第\\(k\\)位以下第一个为\\(1\\)的位，然后检查一下\\(s _1\\)和\\(s _2\\)具体哪一个这位为\\(1\\)就可以了. 当然要特判一下异或的结果全都是\\(0\\)的情况.\n具体实现加法的时候，我是先把从第\\(b\\)位开始的\\(30\\)位拿出来跟\\(a\\)相加，维护\\(s _1\\)异或\\(s _2\\)，再处理一次进位，不知道这么做有没有减小常数.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;bitset\u0026gt;#define ele int using namespace std; #define maxn 1000100 #define maxm 30000100 #define K 30 const ele M0=1\u0026lt;\u0026lt;25; const ele size=M0\u0026lt;\u0026lt;1; ele n,M,t1,t2,t3; bool a[2][maxm]; bool b[size]; inline void maintain(ele i){ b[i]=b[i\u0026lt;\u0026lt;1]|b[i\u0026lt;\u0026lt;1|1]; } inline void upd(ele i){ i+=M; b[i]^=1; while (i\u0026gt;1) maintain(i\u0026gt;\u0026gt;=1); } ele _getl(ele i){ return i\u0026gt;=M?i-M:(b[i\u0026lt;\u0026lt;1|1]?_getl(i\u0026lt;\u0026lt;1|1):_getl(i\u0026lt;\u0026lt;1)); } ele getl(ele i){ return i==1?-1:((i\u0026amp;1) \u0026amp;\u0026amp; b[i^1]?_getl(i^1):getl(i\u0026gt;\u0026gt;1)); } int main(){ scanf(\u0026#34;%d%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;t1,\u0026amp;t2,\u0026amp;t3); M=1; while (M\u0026lt;=n*K) M\u0026lt;\u0026lt;=1; while (n--){ ele op,u,v; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;op,\u0026amp;u); if (op==1){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;v); ele r=0; if (u\u0026lt;0) u=-u,r=1; ele tmp=0; for (int i=v+K-1; i\u0026gt;=v; --i) tmp\u0026lt;\u0026lt;=1,tmp|=a[r][i]; ele t1=tmp; tmp+=u; for (int i=v; i\u0026lt;v+K; ++i){ a[r][i]=(tmp\u0026gt;\u0026gt;(i-v))\u0026amp;1; if ((tmp\u0026gt;\u0026gt;(i-v)\u0026amp;1)!=(t1\u0026gt;\u0026gt;(i-v)\u0026amp;1)) upd(i); } if (tmp\u0026gt;=(1\u0026lt;\u0026lt;K)){ ele j; for (j=v+K; a[r][j]; ++j) a[r][j]=0,upd(j); a[r][j]=1; upd(j); } } else{ ele ans=a[0][u]^a[1][u]; ele i=getl(u+M); if (~i \u0026amp;\u0026amp; a[0][i]\u0026lt;a[1][i]) ans^=1; printf(\u0026#34;%d\\n\u0026#34;,ans); } } return 0; } ","permalink":"https://seraphim.rocks/posts/loj2302/","tags":["题解","loj","二进制减法"],"title":"loj2302题解"},{"categories":null,"contents":"首先注意到给定的区间之间要么不相交，要么嵌套，否则肯定不合法，而且一定有一个覆盖整个序列的区间. 据此我们可以发现区间之间嵌套的关系形成了一个树结构，树中每个点是一个极大的连续的区间. 因此我们只需求出\\(f _i\\)表示长为\\(i+1\\)的，不存在任何不包含最后一位的连续区间的，排列的个数.\n假设\\(a\\)是\\(1,2,\\ldots,n\\)的一个排列，令\\(p _i\\)表示\\(i\\)在\\(a\\)中的位置，易知\\(a\\)中一个连续的区间对应着\\(p\\)中一个连续的区间，因此\\(a\\)满足上一段所述条件等价于\\(p\\)中不存在一个不包含最大值的连续区间.\n考虑跟排列有关的递推我只知道有两种思路，把\\(n+1\\)插入或者在序列某位放一个\\(i\\)，并把前面所有\\(\\ge i\\)的数\\(+1\\). 我一开始想的是后一种思路，结果没想出来. 考虑前一种思路，因为\\(p\\)中不存在一个不包含最大值的连续区间，为方便起见插入\\(1\\)而不是插入\\(n+1\\)，接下来要讨论两种情况. 为方便起见，下面先假设\\(n\\ge 2\\).\n如果插入前的序列是合法的，那么插入前的序列有\\(f _{n-1}\\)种可能，而插入的位置可以是除了插入前最小值旁边的任何位置，共\\(n-1\\)种，因此这种情况的贡献为\\((n-1)f _{n-1}\\).\n如果插入前序列不合法，那么\\(1\\)一定是放在了一个连续区间中间，设它所在的极长连续区间长度为\\(i\\)，那么这段区间插入\\(1\\)后不连续等价于它插入\\(1\\)，离散化后不存在不包含最小值的连续区间，等价于不存在不包含最d大值的连续区间，所以这个连续区间插入\\(1\\)之后共有\\(f _i\\)种可能. 把这段区间缩成一个数，然后把得到的序列离散化，剩下的序列长度为\\(n-i+1\\)，它也不能有不包含最小值的连续区间，共\\(f _{n-i}\\)种可能. 注意到插入\\(1\\)的那个连续区间在离散化之后的权值不能为最小值也不能为最大值，因而有\\(n-i-1\\)种可能. 综上，这一部分的贡献为\n\\[\\sum _{i=2}^{n-1}f _if _{n-i}(n-i-1)=\\sum _{i=2}^{n-2}(i-1)f _if _{n-i} \\]\n于是我们可以列出递推式\n\\[\\begin{aligned}f _n=\u0026\\sum _{i=2}^{n-2}(i-1)f _if _{n-i}+(n-1)f _{n-1}\\\\\\\\=\u0026\\sum _{i=2}^{n-1}(i-1)f _if _{n-i}-(n-3)f _{n-1}\\end{aligned} \\]\n把下标范围弄得对称一些，并加入一些修改使其对\\(\\forall n\\in \\mathbb N\\)都成立\n\\[f _n=\\sum _{i=1}^{n-1}(i-1)f _if _{n-i}-(n-3)f _{n-1}+[n=0] \\]\n这个东西就可以用分治来计算了.\n这个卷积是自己卷自己，但也是可以分治的. 对于每个\\((j-1)f _jf _k\\)，我们在\\(j,k\\)中较大一项被计算出来的时候，统计它的贡献. 把分治的长度补全为\\(2\\)的幂，假设当前的分治区间是\\([l,r)\\)，\\(m=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor\\)，统计\\([l,m)\\)中的\\(f\\)的贡献，分两种情况讨论：\n \\(l\\neq 0\\). 对于\\([l,m)\\)中的每个\\(i\\)，要取一个\\(j\\)使得它们对\\([m,r)\\)有贡献，显然\\(j\\in[0,r-l)\\)，而此时必有\\(r-l\\le l\\)，直接把\\([l,m)\\)中的元素和\\([0,r-l)\\)中的元素卷起来统计贡献就可以了. \\(l=0\\). 直接\\([l,m)\\)中的元素卷上\\([l,m)\\)中的元素.  第一种情况实现精细的话可以用5次而不是6次ntt~~，说不定还可以更少~~.\n这种题卷积的下标范围一定要想办法弄对称，这样细节处理上会方便很多.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; #define maxn (1\u0026lt;\u0026lt;17) #define MOD 998244353 #define g 3 ele n,a[maxn],f[maxn]; inline ele\u0026amp; add(ele\u0026amp;a,ele b){ return a=(a+b\u0026gt;=MOD?a+b-MOD:a+b); } inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } inline void ntt(ele K,ele n,ele *y){ static ele f[maxn]; f[0]=0; for (int i=1; i\u0026lt;n; ++i){ f[i]=f[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1; if (i\u0026amp;1) f[i]+=n\u0026gt;\u0026gt;1; if (i\u0026lt;f[i]) swap(y[i],y[f[i]]); } for (int p=1; p\u0026lt;n; p\u0026lt;\u0026lt;=1){ ele o=pw(g,(MOD-1)/p/2); o=~K?o:pw(o,MOD-2); for (int i=0; i\u0026lt;n; i+=(p\u0026lt;\u0026lt;1)){ ele o1=1; for (int j=i; j\u0026lt;i+p; ++j,o1=(ll)o1*o%MOD){ ele u=y[j],v=(ll)y[j+p]*o1%MOD; y[j]=(u+v)%MOD; y[j+p]=(u-v+MOD)%MOD; } } } if (!~K){ ele invn=pw(n,MOD-2); for (int i=0; i\u0026lt;n; ++i) y[i]=(ll)y[i]*invn%MOD; } } void solve(ele *f,ele l,ele r){ if (r-l\u0026lt;=1) return; ele mid=(l+r)\u0026gt;\u0026gt;1,tmp=(r-l)\u0026lt;\u0026lt;1; solve(f,l,mid); static ele t1[maxn],t2[maxn],t3[maxn],t4[maxn]; if (l){ memset(t1,0,sizeof(ele)*tmp); for (int i=l; i\u0026lt;mid; ++i) t1[i-l]=(ll)f[i]*(i-1)%MOD; memset(t2,0,sizeof(ele)*tmp); for (int i=1; i\u0026lt;r-l; ++i) t2[i]=f[i]; memset(t3,0,sizeof(ele)*tmp); for (int i=2; i\u0026lt;r-l; ++i) t3[i]=(ll)f[i]*(i-1)%MOD; memset(t4,0,sizeof(ele)*tmp); for (int i=l; i\u0026lt;mid; ++i) t4[i-l]=f[i]; ntt(1,tmp,t1); ntt(1,tmp,t2); ntt(1,tmp,t3); ntt(1,tmp,t4); for (int i=0; i\u0026lt;tmp; ++i) t1[i]=((ll)t1[i]*t2[i]%MOD+(ll)t3[i]*t4[i]%MOD)%MOD; ntt(-1,tmp,t1); for (int i=mid; i\u0026lt;r; ++i) add(f[i],t1[i-l]); } else{ memset(t1,0,sizeof(ele)*tmp); for (int i=1; i\u0026lt;mid; ++i) t1[i]=(ll)f[i]*(i-1)%MOD; memset(t2,0,sizeof(ele)*tmp); for (int i=1; i\u0026lt;mid; ++i) t2[i]=f[i]; ntt(1,tmp,t1); ntt(1,tmp,t2); for (int i=0; i\u0026lt;tmp; ++i) t1[i]=(ll)t1[i]*t2[i]%MOD; ntt(-1,tmp,t1); for (int i=mid; i\u0026lt;r; ++i) add(f[i],t1[i]); } add(f[mid],MOD-(ll)f[mid-1]*(mid+MOD-3)%MOD); solve(f,mid,r); } ele calc(ele i){ if (a[i]==1) return 1; ele j=i-1,ans=1,tmp=0; while (j\u0026gt;i-a[i]){ ans=(ll)ans*calc(j)%MOD; j-=a[j]; ++tmp; } if (j\u0026lt;i-a[i]) return 0; ans=(ll)ans*f[tmp]%MOD; return ans; } int main(){ ele T; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;T,\u0026amp;n); f[0]=1; ele tmp=1; while (tmp\u0026lt;=n) tmp\u0026lt;\u0026lt;=1; solve(f,0,tmp); while (T--){ for (int i=0; i\u0026lt;n; ++i) scanf(\u0026#34;%d\u0026#34;,a+i); if (a[n-1]!=n) puts(\u0026#34;0\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;,calc(n-1)); } return 0; } ","permalink":"https://seraphim.rocks/posts/loj2554/","tags":["题解","loj","分治","多项式"],"title":"loj2554题解"},{"categories":null,"contents":"点一下，写一年！A到就是赚到！一个自然的思路是枚举\\(\\textrm{LCA}^\\prime(x,y)\\)，这样\\(x\\)和\\(y\\)在\\(T^\\prime\\)上分属\\(\\textrm{LCA}^\\prime(x,y)\\)的不同子树，剩下在\\(T\\)上的部分可以写成\\(f(x,y)=\\frac{1}{2}(\\textrm{depth}(x)+\\textrm{depth}(y)+\\textrm{dis}(x,y))\\)，可以做类似dsu on a tree的过程来统计答案. 那么我们需要一个数据结构维护一个点集\\(S\\)，支持对一个点\\(u\\)查询\\(\\min _{v \\in S}f(u,v)\\)以及向\\(S\\)中插入一个点.\n像这样维护树上点集，查询权值在边上的信息的时候，可以考虑使用边分治，先对树\\(T\\)建立起一棵边分树，把点集\\(S\\)按照该分治结构划分，形成一棵有\\(O(|S|)\\)个点的树结构，每个点保存\\(\\max\\textrm{depth}(u)+\\textrm{dis}(u,v)\\)，其中\\(u\\)为该点代表的分治结构里面的关键点，\\(v\\)为上一层分治结构的分治边靠近当前分治结构的端点. 那么查询直接在这棵树上面往下走就可以了，插入也可以很容易地处理. 这样我们就可以\\(\\mathcal O(n\\log^2 n)\\)地解决这道题.\n事实上还可以进一步优化，注意到边分树是二叉树结构，可以直接使用类似线段树合并的算法，并顺便计算贡献，而不需要进行启发式合并，这样的复杂度是\\(\\mathcal O(n\\log n)\\).\n边分树是二叉树结构，所以很多东西想起来会更加方便. 但是边分树常数相对会更大，而且如果询问的信息在点上，就不能加入辅助点，复杂度会退化到\\(\\mathcal O(n^2)\\). 刚刚那些东西用点分树理论上可能也是可以做到的，但是会麻烦很多.\n不知道为什么还需要辛辛苦苦卡内存……\n截止到写这篇题解的时候，loj上有若干份AC代码可以对拍出一堆错. 等待数据加强.代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#define ele int #define ll long long using namespace std; #define maxn 733342 #define K 100000 const ll INF=1e18; template\u0026lt;class T\u0026gt;struct mempool{ T *s,*t; mempool():s(NULL),t(NULL){} inline T* alloc(){ return s==t \u0026amp;\u0026amp; (t=(s=new T[K])+K),s++; } }; struct edge{ ele v,w; bool flag; edge *nxt,*rev; }ep[maxn\u0026lt;\u0026lt;2],*ecnt; struct node{ edge *e; ll mx; node *l,*r; }; ele n,acnt,size[maxn],w[maxn]; ll ans,dep[maxn]; edge *h[maxn],*g[maxn],*h1[maxn]; mempool\u0026lt;node\u0026gt; np; vector\u0026lt;ll\u0026gt; vd[maxn]; vector\u0026lt;bool\u0026gt; vc[maxn]; node *T[maxn],*er; inline void boom(){ char *c=NULL; putchar(*c); } inline void addedge1(edge *h[],ele u,ele v,ele w){ edge *p=ecnt++; p-\u0026gt;v=v; p-\u0026gt;w=w; p-\u0026gt;flag=false; p-\u0026gt;nxt=h[u]; p-\u0026gt;rev=ep+((ecnt-ep-1)^1); h[u]=p; } inline void addedge(edge *h[],ele u,ele v,ele w){ addedge1(h,u,v,w); addedge1(h,v,u,w); } void dfs1(ele p,ele i){ ele tmp=i; for (edge *j=h[i]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;v!=p){ addedge(h1,tmp,acnt,0); addedge(h1,acnt,j-\u0026gt;v,j-\u0026gt;w); tmp=acnt++; dfs1(i,j-\u0026gt;v); } } void dfs2(ele p,ele i){ size[i]=1; for (edge *j=h1[i]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;v!=p \u0026amp;\u0026amp; !j-\u0026gt;flag){ dfs2(i,j-\u0026gt;v); size[i]+=size[j-\u0026gt;v]; } } edge* dfs3(ele p,ele i,ele s){ edge *ans=NULL; w[i]=max(size[i],s-size[i]); for (edge *j=h1[i]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;v!=p \u0026amp;\u0026amp; !j-\u0026gt;flag){ edge *tmp=dfs3(i,j-\u0026gt;v,s); if (!ans || (tmp \u0026amp;\u0026amp; w[tmp-\u0026gt;v]\u0026lt;w[ans-\u0026gt;v])) ans=tmp; if (!ans || w[j-\u0026gt;v]\u0026lt;w[ans-\u0026gt;v]) ans=j; } return ans; } void dfs5(ele p,ele i,ll d,ele c){ if (i\u0026lt;n) vd[i].push_back(d),vc[i].push_back(c); for (edge *j=h1[i]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;v!=p \u0026amp;\u0026amp; !j-\u0026gt;flag) dfs5(i,j-\u0026gt;v,d+j-\u0026gt;w,c); } node* build(ele i){ dfs2(-1,i); edge *k=dfs3(-1,i,size[i]); if (!k) return NULL; k-\u0026gt;flag=k-\u0026gt;rev-\u0026gt;flag=true; dfs5(-1,k-\u0026gt;rev-\u0026gt;v,0,0); dfs5(-1,k-\u0026gt;v,0,1); node *p=np.alloc(); p-\u0026gt;e=k; p-\u0026gt;l=build(k-\u0026gt;rev-\u0026gt;v); p-\u0026gt;r=build(k-\u0026gt;v); return p; } void dfs4(ele p,ele i){ for (edge *j=h1[i]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;v!=p) dep[j-\u0026gt;v]=dep[i]+j-\u0026gt;w,dfs4(i,j-\u0026gt;v); } inline void maintain(node *x){ x-\u0026gt;mx=0; if (x-\u0026gt;l) x-\u0026gt;mx=max(x-\u0026gt;mx,x-\u0026gt;l-\u0026gt;mx); if (x-\u0026gt;r) x-\u0026gt;mx=max(x-\u0026gt;mx,x-\u0026gt;r-\u0026gt;mx); } node* build(node *x,ele i,ele j){ node *p=np.alloc(); p-\u0026gt;l=p-\u0026gt;r=NULL; if (!x) return p; p-\u0026gt;e=x-\u0026gt;e; if (!vc[i][j]){ p-\u0026gt;l=build(x-\u0026gt;l,i,j+1); p-\u0026gt;l-\u0026gt;mx=vd[i][j]+dep[i]; } else{ p-\u0026gt;r=build(x-\u0026gt;r,i,j+1); p-\u0026gt;r-\u0026gt;mx=vd[i][j]+dep[i]; } return p; } node* merge(node *a,node *b,ll\u0026amp;ans){ if (!a) return b; if (!b) return a; if (a-\u0026gt;l \u0026amp;\u0026amp; b-\u0026gt;r) ans=max(ans,a-\u0026gt;l-\u0026gt;mx+b-\u0026gt;r-\u0026gt;mx+a-\u0026gt;e-\u0026gt;w); if (a-\u0026gt;r \u0026amp;\u0026amp; b-\u0026gt;l) ans=max(ans,a-\u0026gt;r-\u0026gt;mx+b-\u0026gt;l-\u0026gt;mx+a-\u0026gt;e-\u0026gt;w); a-\u0026gt;l=merge(a-\u0026gt;l,b-\u0026gt;l,ans); a-\u0026gt;r=merge(a-\u0026gt;r,b-\u0026gt;r,ans); a-\u0026gt;mx=max(a-\u0026gt;mx,b-\u0026gt;mx); return a; } void dfs6(ele p,ele i,ll d){ ans=max(ans,dep[i]-d); T[i]=build(er,i,0); for (edge *j=g[i]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;v!=p){ dfs6(i,j-\u0026gt;v,d+j-\u0026gt;w); ll tmp=-INF; T[i]=merge(T[i],T[j-\u0026gt;v],tmp); if (tmp\u0026gt;-INF) ans=max(ans,tmp/2-d); } } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); ecnt=ep; memset(h,0,sizeof(h)); for (int i=0; i\u0026lt;n-1; ++i){ ele u,v,w; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); --u,--v; addedge(h,u,v,w); } memset(g,0,sizeof(g)); for (int i=0; i\u0026lt;n-1; ++i){ ele u,v,w; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); --u,--v; addedge(g,u,v,w); } acnt=n; memset(h1,0,sizeof(h1)); dfs1(-1,0); //\tmemcpy(h1,h,sizeof(h)); \ter=build(0); dep[0]=0; dfs4(-1,0); ans=-INF; dfs6(-1,0,0); printf(\u0026#34;%lld\\n\u0026#34;,ans); //\twhile(1); \treturn 0; } ","permalink":"https://seraphim.rocks/posts/loj2553/","tags":["题解","loj","边分治","线段树合并"],"title":"loj2553题解"},{"categories":null,"contents":"首先考虑\\(m=1\\)的情况，这个时候显然直接二分+按价格贪心就可以了. 如果直接把这个算法应用到原题，复杂度是\\(\\mathcal O(nm\\log^2 n)\\). 结果我就开始想整体二分，想复杂了.\n事实上这种情况下还有一种优化复杂度的思路，就是使用某个数据结构加速单次的查询，即要支持：\n 在果汁集合确定的情况下，快速查询某个\\((g,L)\\)是否可行 可持久化地加入一种果汁  不考虑可持久化的情况下，我的第一反应是按价格顺序维护平衡树然后在上面二分. 这么做的话要可持久化会比较复杂，一个很自然的思路是想办法用线段树去维护它.\n线段树相比平衡树一个很大的缺陷就是不能从中间插入，同样有一个很自然的思路就是预先留好空间，但是一开始存的是0，要插入的时候再将其激活.\n最后复杂度是\\(\\mathcal O(n\\log n+m\\log^2 n)\\).\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele long long using namespace std; #define maxn 100010 #define K 500000 struct jc{ ele d,p,l; inline bool operator\u0026lt;(jc b)const{ return p\u0026lt;b.p; } }a[maxn]; template\u0026lt;class T\u0026gt; struct mempool{ T *s,*t; mempool():s(NULL),t(NULL){} inline T* alloc(){ return s==t \u0026amp;\u0026amp; (t=(s=new T[K])+K),s++; } }; struct node{ ele sl,sp; node *l,*r; }; ele n,m,b[maxn]; node *T[maxn]; mempool\u0026lt;node\u0026gt; np; inline bool cmp(ele i,ele j){ return a[i].d\u0026gt;a[j].d; } node* build(ele l,ele r){ node *p=np.alloc(); p-\u0026gt;sl=p-\u0026gt;sp=0; if (l==r) p-\u0026gt;l=p-\u0026gt;r=NULL; else{ ele mid=(l+r)\u0026gt;\u0026gt;1; p-\u0026gt;l=build(l,mid); p-\u0026gt;r=build(mid+1,r); } return p; } inline void maintain(node *x){ x-\u0026gt;sl=x-\u0026gt;l-\u0026gt;sl+x-\u0026gt;r-\u0026gt;sl; x-\u0026gt;sp=x-\u0026gt;l-\u0026gt;sp+x-\u0026gt;r-\u0026gt;sp; } node* upd(node *x,ele u,ele v,ele i){ node *p=np.alloc(); *p=*x; if (u==v){ p-\u0026gt;sl=a[u].l; p-\u0026gt;sp=a[u].l*a[u].p; } else{ ele mid=(u+v)\u0026gt;\u0026gt;1; if (i\u0026lt;=mid) p-\u0026gt;l=upd(p-\u0026gt;l,u,mid,i); else p-\u0026gt;r=upd(p-\u0026gt;r,mid+1,v,i); maintain(p); } return p; } ele qry(node *x,ele u,ele v,ele k){ if (u==v) return k*a[u].p; ele mid=(u+v)\u0026gt;\u0026gt;1; if (k\u0026lt;=x-\u0026gt;l-\u0026gt;sl) return qry(x-\u0026gt;l,u,mid,k); return qry(x-\u0026gt;r,mid+1,v,k-x-\u0026gt;l-\u0026gt;sl)+x-\u0026gt;l-\u0026gt;sp; } inline bool test(ele r,ele g,ele L){ return T[r]-\u0026gt;sl\u0026gt;=L \u0026amp;\u0026amp; qry(T[r],0,n-1,L)\u0026lt;=g; } int main(){ scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;m); for (int i=0; i\u0026lt;n; ++i){ ele d,p,l; scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;d,\u0026amp;p,\u0026amp;l); a[i]=(jc){d,p,l}; } sort(a,a+n); for (int i=0; i\u0026lt;n; ++i) b[i]=i; sort(b,b+n,cmp); T[0]=build(0,n-1); for (int i=0; i\u0026lt;n; ++i) T[i+1]=upd(T[i],0,n-1,b[i]); while (m--){ ele g,L; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;g,\u0026amp;L); if (T[n]-\u0026gt;sl\u0026lt;L) puts(\u0026#34;-1\u0026#34;); else{ ele l=0,r=n; while (r-l\u0026gt;1){ ele mid=(l+r)\u0026gt;\u0026gt;1; if (test(mid,g,L)) r=mid; else l=mid; } if (test(r,g,L)) printf(\u0026#34;%lld\\n\u0026#34;,a[b[r-1]].d); else puts(\u0026#34;-1\u0026#34;); } } return 0; } ","permalink":"https://seraphim.rocks/posts/loj2555/","tags":["题解","loj","可持久化线段树"],"title":"loj2555题解"},{"categories":null,"contents":"由于代码习惯，下文中用\\(h _i\\)表示题目中的\\(m _i\\).\n看到998244353不知道为什么就去想NTT……其实完全没有必要，因为\\(n\\)和\\(C\\)和\\(h _i\\)都非常小.\n记\\(f _{i,j}\\)表示\\(i\\)这个人生命值恰为\\(j\\)的概率，直接暴力dp，每次更新复杂度为\\(\\mathcal O(m)\\). 这样就可以求出最后每个人生命值的期望.\n考虑怎么求另一问，显然\\(f _{i,0}\\)就是\\(i\\)这个人死去的概率. 记\\(\\textrm{al} _{i,j}\\)表示除了\\(i\\)以外还活下来\\(j\\)个人的概率，显然可以\\(\\mathcal O(n^3)\\)dp出来. 其实这样做了很多重复的工作，可以直接求出\\(\\textrm{al} _j\\)表示有\\(j\\)个人活下来的概率，那么要除去某个人，相当于是从背包里面删去一个元素，考虑之前的递推式\\(\\textrm{al}^\\prime _i=\\textrm{al} _i f _{x,0}+\\textrm{al} _{i-1}(1-f _{x,0})\\)，可以得到\\(\\textrm{al} _i=\\frac{\\textrm{al}^\\prime _i-\\textrm{al} _{i-1}(1-f _{x,0})}{f _{x,0}}\\)，这样就能从背包中删去一个元素了. 这部分计算的复杂度就降到了\\(\\mathcal O(n^2)\\).\n最后的复杂度是\\(\\mathcal O(Qm+Cn^2)\\).\n线性预处理\\(1,2,\\ldots,n\\)的逆元可以显著减小常数.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; #define maxn 210 #define maxh 110 #define MOD 998244353 ele n,Q,k,h[maxn],f[maxn][maxh],g[maxh],a[maxn],al[maxn],tal[maxn],inv[maxn]; inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); inv[1]=1; for (int i=2; i\u0026lt;=n; ++i) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD; memset(f,0,sizeof(f)); for (int i=0; i\u0026lt;n; ++i) scanf(\u0026#34;%d\u0026#34;,h+i),f[i][h[i]]=1; scanf(\u0026#34;%d\u0026#34;,\u0026amp;Q); while (Q--){ ele op; scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); if (!op){ ele i,u,v; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;i,\u0026amp;u,\u0026amp;v); --i; u=(ll)u*pw(v,MOD-2)%MOD; g[0]=((ll)f[i][1]*u+f[i][0])%MOD; for (int j=1; j\u0026lt;=h[i]; ++j) g[j]=((ll)f[i][j]*(1+MOD-u)+(ll)f[i][j+1]*u)%MOD; memcpy(f[i],g,sizeof(ele)*(h[i]+1)); } else{ scanf(\u0026#34;%d\u0026#34;,\u0026amp;k); for (int i=0; i\u0026lt;k; ++i) scanf(\u0026#34;%d\u0026#34;,a+i),--a[i]; memset(al,0,sizeof(al)); al[0]=1; for (int i=0; i\u0026lt;k; ++i){ tal[0]=(ll)al[0]*f[a[i]][0]%MOD; for (int j=1; j\u0026lt;=k; ++j) tal[j]=((ll)al[j]*f[a[i]][0]+(ll)al[j-1]*(1+MOD-f[a[i]][0]))%MOD; memcpy(al,tal,sizeof(ele)*(k+1)); } for (int i=0; i\u0026lt;k; ++i){ if (f[a[i]][0]){ ele tmp=pw(f[a[i]][0],MOD-2); tal[0]=(ll)al[0]*tmp%MOD; for (int j=1; j\u0026lt;=k; ++j) tal[j]=(ll)tmp* (al[j]+MOD-(ll)tal[j-1]*(1+MOD-f[a[i]][0])%MOD)%MOD; } else memcpy(tal,al+1,sizeof(ele)*k); ele ans=0; for (int j=0; j\u0026lt;k; ++j) (ans+=(ll)inv[j+1]*(1+MOD-f[a[i]][0])%MOD*tal[j]%MOD)%=MOD; printf(i?\u0026#34; %d\u0026#34;:\u0026#34;%d\u0026#34;,ans); } puts(\u0026#34;\u0026#34;); } } for (int i=0; i\u0026lt;n; ++i){ ele ans=0; for (int j=0; j\u0026lt;=h[i]; ++j) (ans+=(ll)j*f[i][j]%MOD)%=MOD; printf(i?\u0026#34; %d\u0026#34;:\u0026#34;%d\u0026#34;,ans); } puts(\u0026#34;\u0026#34;); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2552/","tags":["题解","loj","DP","背包删除"],"title":"loj2552题解"},{"categories":null,"contents":"看了题解才发现loj上面的题面漏了一小部分……uoj上的题面是完整的.\n由Lucas定理易知\\(\\binom{n}{m}\\equiv 1\\pmod{2}\\leftrightarrow m\\subset n\\).\n让\\(f _{i,j}\\)表示从\\(i\\)位置或\\(i\\)位置之后开始的，所有数都包含于\\(j\\)的子序列的方案数，转移显然.\\(i\\)那一维可以直接滚动，因为题目保证输入的数互不相同，所以复杂度不会超过枚举子集的复杂度，即\\(\\mathcal O(3^{\\log _2a})\\)，也就是\\(\\mathcal O(a^{\\log _23})\\).\n辣鸡bzoj就非得要我把取模改成减法卡卡常数才让我过……\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int using namespace std; #define maxn 220010 #define maxa (1\u0026lt;\u0026lt;18) #define MOD 1000000007 ele n,mx,a[maxn],f[maxa],g[maxa]; inline ele add(ele x,ele y){ return (x+y\u0026gt;=MOD)?x+y-MOD:x+y; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for (int i=0; i\u0026lt;n; ++i) scanf(\u0026#34;%d\u0026#34;,a+i),mx=max(mx,a[i]); memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); for (int i=n-1; ~i; --i){ ele tmp=0; for (int s=a[i]; s; s=(s-1)\u0026amp;a[i]) tmp=add(tmp,add(f[s],g[s])); f[a[i]]=add(f[a[i]],tmp); ++g[a[i]]; } ele ans=0; for (int i=0; i\u0026lt;=mx; ++i) ans=add(ans,f[i]); printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2264/","tags":["题解","loj","数论","Lucas定理"],"title":"loj2264题解"},{"categories":null,"contents":"因为圆是从大往小选的，所以每次选出一个圆，它能删掉的圆一定在两倍半径范围之内，假设我们有一个数据结构可以快速把两倍半径范围内的圆找出来，那么直接对这些圆暴力判交就可以了.\n我们考虑这个算法中，每个圆会跟多少个比它大的圆暴力判交. 假设这些圆构成集合\\(S\\)，那么\\(S\\)中的圆两两不交（否则一定有一个会被另一个先删去）. 于是\\(S\\)中的圆最多只有常数个，因此这么做的时间复杂度是得到保障的.\n现在问题变成如何快速找出两倍半径范围内的圆. 理论上kdtree是可以做的，但我也不知道为什么就T飞了……\n事实上，我们不需要真的只找出两倍半径以内的圆，可以划分得更粗略一些. 假设当前选出的圆半径为\\(r\\)，我们可以把平面划分成若干个\\(r\\times r\\)的格子，找出以当前圆为中心的\\(5\\times 5\\)的网格中的所有圆，时间复杂度的证明同上. 此时，如果\\(r\\)是确定的，那么用hashmap套vector就可以维护了. 不过现在\\(r\\)是不确定的，如果每次\\(r\\)变化都重新划分的话，时间复杂度就会达到\\(\\mathcal O(n^2)\\)，还不如暴力. 这个时候我们可以划分得再粗略一些，对于半径为\\(r\\)的选出的圆，取\\(k=\\max _{2^{k _0}\\ge r}k _0\\)，把平面划分成若干个\\(2^k\\times 2^k\\)的格子. 这样重新划分的次数为\\(\\mathcal O(\\log x)\\)，时间复杂度的证明仍然类似上面.\n最后的时间复杂度为\\(\\mathcal O(n\\log x)\\).\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt;#define ele long long #define fi first #define se second using namespace std; #define maxn 300010 ele n,w,mx,x[maxn],y[maxn],r[maxn],a[maxn],res[maxn]; unordered_map\u0026lt;ele,vector\u0026lt;pair\u0026lt;ele,ele\u0026gt; \u0026gt; \u0026gt; mp; inline bool cmp1(ele i,ele j){ return (r[i]==r[j])?i\u0026lt;j:r[i]\u0026gt;r[j]; } inline void clear(){ for (auto it=mp.begin(); it!=mp.end(); ++it) it-\u0026gt;se.clear(); mp.clear(); } inline void build(){ for (int i=0; i\u0026lt;n; ++i) mp[x[i]\u0026gt;\u0026gt;w].push_back(make_pair(y[i],i)); for (auto it=mp.begin(); it!=mp.end(); ++it) sort(it-\u0026gt;se.begin(),it-\u0026gt;se.end()); } inline ele _sqr(ele x){ return x*x; } inline void test(ele i,ele j){ if (~res[j]) return; if (_sqr(x[i]-x[j])+_sqr(y[i]-y[j])\u0026lt;=_sqr(r[i]+r[j])) res[j]=i; } int main(){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); mx=0; for (int i=0; i\u0026lt;n; ++i) scanf(\u0026#34;%lld%lld%lld\u0026#34;,x+i,y+i,r+i),mx=max(mx,r[i]); w=1; while ((1\u0026lt;\u0026lt;w)\u0026lt;mx) ++w; build(); memset(res,-1,sizeof(res)); for (int i=0; i\u0026lt;n; ++i) a[i]=i; sort(a,a+n,cmp1); for (int j=0; j\u0026lt;n; ++j){ if (~res[a[j]]) continue; ele i=a[j]; if (w \u0026amp;\u0026amp; ((1\u0026lt;\u0026lt;w-1)\u0026gt;=r[i])){ while ((1\u0026lt;\u0026lt;w-1)\u0026gt;=r[i]) --w; clear(); build(); } for (int k=(x[i]\u0026gt;\u0026gt;w)-2; k\u0026lt;=(x[i]\u0026gt;\u0026gt;w)+2; ++k){ if (mp.find(k)==mp.end()) continue; ele u=lower_bound(mp[k].begin(),mp[k].end(),make_pair(y[i]-r[i]*2,0ll)) -mp[k].begin(); ele v=upper_bound(mp[k].begin(),mp[k].end(),make_pair(y[i]+r[i]*2,n)) -mp[k].begin(); for (int p=u; p\u0026lt;v; ++p) test(i,mp[k][p].se); } } for (int i=0; i\u0026lt;n; ++i) printf(i?\u0026#34; %lld\u0026#34;:\u0026#34;%lld\u0026#34;,res[i]+1); puts(\u0026#34;\u0026#34;); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2586/","tags":["题解","loj","粗略划分"],"title":"loj2586题解"},{"categories":null,"contents":"算是一个我不太熟悉的技巧吧……感觉大家都会，就我一个考场上没想出来.\n单独考虑某一种商店类型到居住点的距离，它关于坐标的函数一定是一条折线，而且每一段的斜率都只可能是1或-1. 因为最后相当于要把一堆折线取max，所以每一条折线可以看作是一堆射线，即斜率为1的段只考虑右端点，斜率为-1的段只考虑左端点. 这样一来，查询就是给定某个横坐标求这个横坐标上各条射线的最高点，修改就是加入若干条射线，删除若干条射线.\n考虑用一个数据结构维护这些射线，我的第一反应是lych线段树，但是它不支持删除. 注意到斜率只有两种，而相同斜率的射线方向都是一样的，我们可以把射线按斜率分开，分别按端点横坐标排序，同时维护截距. 那么每次查询其实就是查前缀/后缀的最大截距，插入和删除就是简单的单点修改，用一个平衡树来维护就可以了.\n复杂度是一个\\(\\log\\)的，但是常数应该比较大，截止到写这篇题解的时候，我的代码是loj上AC代码里面最慢的.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;set\u0026gt;#define ele long long using namespace std; #define maxn 600010 #define K 500000 const ele INF=2e9; struct evt{ ele ty,x,t,a; inline bool operator\u0026lt;(evt b)const{ return a\u0026lt;b.a; } }; struct ask{ ele l,y,id; inline bool operator\u0026lt;(ask b)const{ return y\u0026lt;b.y; } }; struct node{ ele i,b,mx,p; node *l,*r; node(){ p=rand(); l=r=NULL; } inline ele cmp(ele i,ele b){ if (i!=this-\u0026gt;i) return i\u0026lt;this-\u0026gt;i?0:1; if (b!=this-\u0026gt;b) return b\u0026lt;this-\u0026gt;b?0:1; return -1; } }; template\u0026lt;class T\u0026gt;struct mempool{ T *s,*t; mempool():s(NULL),t(NULL){} inline T* alloc(){ return s==t \u0026amp;\u0026amp; (t=(s=new T[K])+K),s++; } }; ele n,k,Q,tot,cnt[maxn],res[maxn]; evt e[maxn]; ask q[maxn]; multiset\u0026lt;ele\u0026gt; S[maxn]; mempool\u0026lt;node\u0026gt; np; node *r1,*r2; inline void maintain(node *x){ x-\u0026gt;mx=x-\u0026gt;b; if (x-\u0026gt;l) x-\u0026gt;mx=max(x-\u0026gt;mx,x-\u0026gt;l-\u0026gt;mx); if (x-\u0026gt;r) x-\u0026gt;mx=max(x-\u0026gt;mx,x-\u0026gt;r-\u0026gt;mx); } node* merge(node *a,node *b){ if (!a) return b; if (!b) return a; if (a-\u0026gt;p\u0026gt;b-\u0026gt;p){ a-\u0026gt;r=merge(a-\u0026gt;r,b); maintain(a); return a; } else{ b-\u0026gt;l=merge(a,b-\u0026gt;l); maintain(b); return b; } } void split(node *x,ele k,ele b1,node*\u0026amp;a,node*\u0026amp;b){ if (!x){ a=b=NULL; return; } if (!x-\u0026gt;cmp(k,b1)){ split(x-\u0026gt;l,k,b1,a,b); x-\u0026gt;l=b; maintain(x); b=x; } else{ split(x-\u0026gt;r,k,b1,a,b); x-\u0026gt;r=a; maintain(x); a=x; } } inline node* ins(node *x,ele i,ele b){ node *p=np.alloc(); p-\u0026gt;i=i; p-\u0026gt;b=b; maintain(p); node *u,*v; split(x,i,b,u,v); x=merge(u,p); x=merge(x,v); return x; } inline node* del(node *x,ele i,ele b){ node *u,*v,*w; split(x,i,b,v,w); split(v,i,b-1,u,v); if (v) v=merge(v-\u0026gt;l,v-\u0026gt;r); else v=NULL; x=merge(u,v); x=merge(x,w); return x; } inline void ins(ele x,ele y){ ele L=(y-x)/2; r1=ins(r1,x+L,-x); r2=ins(r2,y-L,y); } inline void del(ele x,ele y){ ele L=(y-x)/2; r1=del(r1,x+L,-x); r2=del(r2,y-L,y); } int main(){ scanf(\u0026#34;%lld%lld%lld\u0026#34;,\u0026amp;n,\u0026amp;k,\u0026amp;Q); for (int i=0; i\u0026lt;n; ++i){ ele x,t,a,b; scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;,\u0026amp;x,\u0026amp;t,\u0026amp;a,\u0026amp;b); --t; e[i\u0026lt;\u0026lt;1]=(evt){1,x,t,a}; e[i\u0026lt;\u0026lt;1|1]=(evt){-1,x,t,b+1}; } sort(e,e+n*2); for (int i=0; i\u0026lt;Q; ++i){ ele l,y; scanf(\u0026#34;%lld%lld\u0026#34;,\u0026amp;l,\u0026amp;y); q[i]=(ask){l,y,i}; } sort(q,q+Q); tot=0; memset(cnt,0,sizeof(cnt)); r1=r2=NULL; for (int i=0; i\u0026lt;k; ++i) S[i].insert(-INF),S[i].insert(INF),ins(-INF,INF); ele j=0; for (int i=0; i\u0026lt;Q; ++i){ for (; j\u0026lt;n*2 \u0026amp;\u0026amp; e[j].a\u0026lt;=q[i].y; ++j) if (~e[j].ty){ if (!cnt[e[j].t]) ++tot; ++cnt[e[j].t]; S[e[j].t].insert(e[j].x); auto it=S[e[j].t].find(e[j].x),it1=it,it2=it; --it1; ++it2; del(*it1,*it2); ins(*it1,*it); ins(*it,*it2); } else{ --cnt[e[j].t]; if (!cnt[e[j].t]) --tot; auto it=S[e[j].t].find(e[j].x),it1=it,it2=it; --it1; ++it2; del(*it1,*it); del(*it,*it2); ins(*it1,*it2); S[e[j].t].erase(it); } if (tot!=k) res[q[i].id]=-1; else{ ele ans=0; node *u,*v; split(r1,q[i].l-1,INF,u,v); ans=max(ans,v-\u0026gt;mx+q[i].l); r1=merge(u,v); split(r2,q[i].l,INF,u,v); ans=max(ans,u-\u0026gt;mx-q[i].l); r2=merge(u,v); res[q[i].id]=ans; } } for (int i=0; i\u0026lt;Q; ++i) printf(\u0026#34;%lld\\n\u0026#34;,res[i]); return 0; } ","permalink":"https://seraphim.rocks/posts/loj2585/","tags":["题解","loj","维护折线"],"title":"loj2585题解"},{"categories":null,"contents":"令\\(f _{i,j,k}\\)表示\\(i\\)位，模\\(p\\)余\\(j\\)，数字和恰好为\\(k\\)的数的个数，那么可以写出递推式\n\\[f _{i+1,j,k}=\\sum _{10j _1+j _2\\equiv j\\pmod{p},~k _1+k _2=k}f _{i,j _1,k _1} \\]\n可以发现这很像一个卷积的形式，但是\\(j\\)这一维很难用多项式来优化. 这个时候可以考虑倍增，列出更一般的递推式\n\\[f _{i _1+i _2,j,k}=\\sum _{10^{i _2}j _1+j _2\\equiv j\\pmod{p},~k _1+k _2=k}f _{i _1,j _1,k _1}f _{i _2,j _2,k _2} \\]\n这样让\\(F _i(x,y)=\\sum f _{i,j,k}x^jy^k\\)就可以用倍增+NTT来加速了，（\\(x\\)直接暴力卷积，\\(y\\)用NTT优化）.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; #define maxn 2048 #define maxp 55 #define MOD 998244353 #define g 3 ele n,p,m,a[maxp][maxn],b[maxp][maxn]; inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } inline void NTT(ele K,ele n,ele *y){ static ele f[maxn]; f[0]=0; for (int i=1; i\u0026lt;n; ++i){ f[i]=f[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1; if (i\u0026amp;1) f[i]+=n\u0026gt;\u0026gt;1; if (i\u0026lt;f[i]) swap(y[i],y[f[i]]); } for (int p=1; p\u0026lt;n; p\u0026lt;\u0026lt;=1){ ele o=pw(g,(MOD-1)/p/2); o=~K?o:pw(o,MOD-2); for (int i=0; i\u0026lt;n; i+=(p\u0026lt;\u0026lt;1)){ ele o1=1; for (int j=i; j\u0026lt;i+p; ++j,o1=(ll)o1*o%MOD){ ele u=y[j],v=(ll)y[j+p]*o1%MOD; y[j]=(u+v)%MOD; y[j+p]=(u-v+MOD)%MOD; } } } if (!~K){ ele invn=pw(n,MOD-2); for (int i=0; i\u0026lt;n; ++i) y[i]=(ll)y[i]*invn%MOD; } } inline void mul(ele a[maxp][maxn],ele b[maxp][maxn],ele k){ static ele c[maxp][maxn],d[maxp][maxn],e[maxp][maxn]; memset(c,0,sizeof(c)); ele tmp=1; while (tmp\u0026lt;m+m-1) tmp\u0026lt;\u0026lt;=1; memset(d,0,sizeof(d)); memcpy(e,b,sizeof(e)); for (int i=0; i\u0026lt;p; ++i){ ele j=i*k%p; for (int r=0; r\u0026lt;m; ++r) (d[j][r]+=a[i][r])%=MOD; } for (int i=0; i\u0026lt;p; ++i) NTT(1,tmp,d[i]),NTT(1,tmp,e[i]); for (int i=0; i\u0026lt;p; ++i) for (int j=0; j\u0026lt;p; ++j){ ele k=(i+j)%p; for (int r=0; r\u0026lt;tmp; ++r) (c[k][r]+=(ll)d[i][r]*e[j][r]%MOD)%=MOD; } memcpy(a,c,sizeof(c)); for (int i=0; i\u0026lt;p; ++i) NTT(-1,tmp,a[i]); for (int i=0; i\u0026lt;p; ++i) for (int j=m; j\u0026lt;tmp; ++j) a[i][j]=0; } int main(){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;p,\u0026amp;m); ++m; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); a[0][0]=1; for (int i=0; i\u0026lt;10 \u0026amp;\u0026amp; i\u0026lt;m; ++i) b[i%p][i]+=1; ele k=10; for (; n; n\u0026gt;\u0026gt;=1,mul(b,b,k),k=k*k%p) if (n\u0026amp;1) mul(a,b,k); ele cnt=0; for (int i=0; i\u0026lt;m; ++i) (cnt+=a[0][i])%=MOD,printf(i?\u0026#34; %d\u0026#34;:\u0026#34;%d\u0026#34;,cnt); puts(\u0026#34;\u0026#34;); return 0; } ","permalink":"https://seraphim.rocks/posts/loj6059/","tags":["题解","loj","倍增","多项式"],"title":"loj6059题解"},{"categories":null,"contents":"智商有点下线想复杂了.\n我的做法是考虑树剖，这样每个查询可以看做序列上至多\\(\\mathcal O(\\log n)\\)段的查询.最大异或值可以用trie来做，那么就可以把询问离线然后在线段树上对trie做启发式合并了. 其实可以不用写启发式合并，写一个类似线段树合并的东西. 这样做是三个\\(\\log\\)的，但是树剖的那个\\(\\log\\)很小，所以可以过.\n但是其实只需要用可持久化trie做就可以了……\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#define ele int using namespace std; #define maxn 100010 #define maxk 31 struct edge{ ele v; edge *nxt; }ep[maxn\u0026lt;\u0026lt;1],*ecnt; struct tn{ tn *c[2]; }tnp[maxn*(maxk+2)],*tncnt; struct node{ tn *t; vector\u0026lt;ele\u0026gt; v; node *l,*r; }np[maxn\u0026lt;\u0026lt;2],*ncnt; ele n,Q,tcnt,v[maxn],seq[maxn],dfn[maxn],fa[maxn],size[maxn],dep[maxn],r[maxn],a[maxn],res[maxn]; edge *h[maxn],*hc[maxn]; node *root; inline void addedge(ele u,ele v){ edge *p=ecnt++; p-\u0026gt;v=v; p-\u0026gt;nxt=h[u]; h[u]=p; } inline ele getv(ele x,ele i){ return (x\u0026gt;\u0026gt;i)\u0026amp;1; } tn* ins(tn *x,ele y,ele i){ if (!x){ x=tncnt++; x-\u0026gt;c[0]=x-\u0026gt;c[1]=NULL; } if (~i) x-\u0026gt;c[getv(y,i)]=ins(x-\u0026gt;c[getv(y,i)],y,i-1); return x; } tn* merge(tn *x,tn *y){ if (!x) return y; if (!y) return x; x-\u0026gt;c[0]=merge(x-\u0026gt;c[0],y-\u0026gt;c[0]); x-\u0026gt;c[1]=merge(x-\u0026gt;c[1],y-\u0026gt;c[1]); return x; } node* build(ele l,ele r){ node *p=ncnt++; p-\u0026gt;v.clear(); if (l==r) p-\u0026gt;t=ins(NULL,v[seq[l]],maxk),p-\u0026gt;l=p-\u0026gt;r=NULL; else{ ele mid=(l+r)\u0026gt;\u0026gt;1; p-\u0026gt;l=build(l,mid); p-\u0026gt;r=build(mid+1,r); } return p; } void upd(node *x,ele a,ele b,ele l,ele r,ele i){ if (l\u0026lt;=a \u0026amp;\u0026amp; b\u0026lt;=r) x-\u0026gt;v.push_back(i); else{ ele mid=(a+b)\u0026gt;\u0026gt;1; if (l\u0026lt;=mid) upd(x-\u0026gt;l,a,mid,l,r,i); if (mid\u0026lt;r) upd(x-\u0026gt;r,mid+1,b,l,r,i); } } void dfs1(ele p,ele i){ size[i]=1; hc[i]=NULL; fa[i]=p; for (edge *j=h[i]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;v!=p){ dep[j-\u0026gt;v]=dep[i]+1; dfs1(i,j-\u0026gt;v); size[i]+=size[j-\u0026gt;v]; if (!hc[i] || size[j-\u0026gt;v]\u0026gt;size[hc[i]-\u0026gt;v]) hc[i]=j; } } void dfs2(ele p,ele i){ dfn[i]=tcnt; seq[tcnt++]=i; if (hc[i]){ r[hc[i]-\u0026gt;v]=r[i]; dfs2(i,hc[i]-\u0026gt;v); } for (edge *j=h[i]; j; j=j-\u0026gt;nxt) if (j-\u0026gt;v!=p \u0026amp;\u0026amp; j!=hc[i]){ r[j-\u0026gt;v]=j-\u0026gt;v; dfs2(i,j-\u0026gt;v); } } inline ele lca(ele x,ele y){ while (r[x]!=r[y]){ if (dep[r[x]]\u0026lt;dep[r[y]]) swap(x,y); x=fa[r[x]]; } return dep[x]\u0026lt;dep[y]?x:y; } inline void upd(ele x,ele y,ele i){ while (~x \u0026amp;\u0026amp; dep[x]\u0026gt;dep[y]){ if (dep[r[x]]\u0026gt;dep[y]) upd(root,0,n-1,dfn[r[x]],dfn[x],i); else upd(root,0,n-1,dfn[y]+1,dfn[x],i); x=fa[r[x]]; } } ele qry(tn *x,ele y,ele i){ if (!~i) return 0; ele t=getv(y,i)^1; ele ans=x-\u0026gt;c[t]?qry(x-\u0026gt;c[t],y,i-1)+(1\u0026lt;\u0026lt;i):qry(x-\u0026gt;c[t^1],y,i-1); return ans; } void dfs3(node *x){ if (x-\u0026gt;l){ dfs3(x-\u0026gt;l); dfs3(x-\u0026gt;r); x-\u0026gt;t=merge(x-\u0026gt;l-\u0026gt;t,x-\u0026gt;r-\u0026gt;t); } for (int j=0; j\u0026lt;x-\u0026gt;v.size(); ++j){ ele i=x-\u0026gt;v[j]; res[i]=max(res[i],qry(x-\u0026gt;t,a[i],maxk)); } } int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;Q); for (int i=0; i\u0026lt;n; ++i) scanf(\u0026#34;%d\u0026#34;,v+i); ecnt=ep; memset(h,0,sizeof(h)); for (int i=0; i\u0026lt;n-1; ++i){ ele u,v; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;u,\u0026amp;v); --u,--v; addedge(u,v); addedge(v,u); } dep[0]=0; dfs1(-1,0); tcnt=0; r[0]=0; dfs2(-1,0); ncnt=np; tncnt=tnp; root=build(0,n-1); for (int i=0; i\u0026lt;Q; ++i){ ele op,x,y,z; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;op,\u0026amp;x,\u0026amp;y); --x; if (op==1){ a[i]=y; upd(root,0,n-1,dfn[x],dfn[x]+size[x]-1,i); } else if (op==2){ --y; scanf(\u0026#34;%d\u0026#34;,\u0026amp;z); a[i]=z; ele w=lca(x,y); upd(x,w,i); upd(y,w,i); upd(root,0,n-1,dfn[w],dfn[w],i); } } memset(res,0,sizeof(res)); dfs3(root); for (int i=0; i\u0026lt;Q; ++i) printf(\u0026#34;%d\\n\u0026#34;,res[i]); return 0; } ","permalink":"https://seraphim.rocks/posts/bzoj5338/","tags":["题解","bzoj","树链剖分","trie","dsu on a tree"],"title":"bzoj5338题解"},{"categories":null,"contents":"定义\\(f(x,y)=\\prod _{i=0}^{n-1}(1+x^iy)\\)，这里做乘法的时候\\(x\\)是模\\(n\\)的循环卷积，而y是普通卷积. 那么答案就是\\([x^0y^k]f(x,y)\\).\n这个循环卷积不好处理，注意到DFT本质上就是一个循环卷积，我们可以考虑使用IDFT，答案就是\n\\[\\frac{1}{n}[y^k]\\sum f(\\omega _n^i,y)\\omega _n^{-i\\cdot 0} \\]\n想办法化简这个式子\n\\[\\begin{aligned}\u0026\\sum f(\\omega _n^i,y)\\\\\\\\=\u0026\\sum _{i=0}^{n-1}\\prod _{j=0}^{n-1}(1+\\omega _n^{ij}y)\\\\\\\\=\u0026\\sum _{d|n}\\sum _{(i,n)=d}\\prod _{j=0}^{n-1}(1+(\\omega _{n/d}^{i/d})^jy)\\\\\\\\=\u0026\\sum _{d|n}\\sum _{(i,n)=d}\\prod _{j=0}^{n-1}(1+\\omega _{n/d}^jy)\\\\\\\\=\u0026\\sum _{d|n}\\sum _{(i,n)=d}(\\prod _{j=0}^{n/d-1}(1+\\omega _{n/d}^jy))^d\\end{aligned} \\]\n这个时候要用到一个结论\n\\[\\prod _{i=0}^{n-1}(x-\\omega _n^iy)=x^n-y^n \\]\n证明的话，把\\(x=\\omega _n^iy(i=0,1,\\ldots,n-1)\\)带入，发现两边都是0，而两边都是\\(n\\)次的，说明这是个恒等式.\n把\\(x=-1\\)带入上式，两边再乘上\\((-1)^n\\)，就可以得到\n\\[\\prod _{i=0}^{n-1}(1+\\omega _n^iy)=1-(-y)^n \\]\n回到我们原来要推的那个式子，可以变形为\n\\[\\begin{aligned}\u0026\\sum _{d|n}\\sum _{(i,n)=d}(\\prod _{j=0}^{n/d-1}(1+\\omega _{n/d}^jy))^d\\\\\\\\=\u0026\\sum _{d|n}\\sum _{(i,n)=d}(1-(-y)^{n/d})^d\\\\\\\\=\u0026\\sum _{d|n}(1-(-y)^{n/d})^d\\varphi(n/d)\\end{aligned} \\]\n要求这个式子中\\(y^k\\)的系数，直接用二项式定理展开就可以了. 组合数可以把阶乘分段打表来算.\n可以注意到，\\(k\\)的范围扩大到\\(10^9\\)也是可以做的，要求的余数不是0而是一个由输入给定的值也是可以做的（当然式子需要再推一推）.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; #define maxk 1010 #define MOD 1000000007 #define K 400000 const ele tf[]={};//这里省略阶乘的表 ele n,k,phi[maxk]; inline ele get_phi(ele n){ ele ans=n,tmp=n; for (int i=2; i*i\u0026lt;=n; ++i) if (tmp%i==0){ ans/=i; ans*=i-1; while (tmp%i==0) tmp/=i; } if (tmp\u0026gt;1) ans/=tmp,ans*=tmp-1; return ans; } inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } inline ele fac(ele n){ ele ans=tf[n/K]; for (int i=n/K*K+1; i\u0026lt;=n; ++i) ans=(ll)ans*i%MOD; return ans; } inline ele ifac(ele n){ return pw(fac(n),MOD-2); } inline ele C(ele n,ele m){ return (ll)fac(n)*ifac(m)%MOD*ifac(n-m)%MOD; } inline ele calc(ele d){ if (k%(n/d)) return 0; ele c=k/(n/d); ele ans=(ll)C(d,c)*phi[n/d]%MOD; if (n/d%2==0 \u0026amp;\u0026amp; c%2) ans=ans?MOD-ans:0; return ans; } int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); for (int i=1; i\u0026lt;=k; ++i) phi[i]=get_phi(i); ele ans=0; for (int d=1; d*d\u0026lt;=n; ++d) if (n%d==0){ (ans+=calc(d))%=MOD; if (d*d!=n) (ans+=calc(n/d))%=MOD; } ans=(ll)ans*pw(n,MOD-2)%MOD; printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } ","permalink":"https://seraphim.rocks/posts/bzoj4314/","tags":["题解","bzoj","数论","DFT","多项式"],"title":"bzoj4314题解"},{"categories":null,"contents":"几年前刚学矩阵快速幂的时候点开了这道题，写了半天始终TLE，一看题解发现完全看不懂……时隔多年终于A掉了这道题.\n因为代码习惯，下文中用\\(n\\)表示题目中的\\(k\\)，用\\(s\\)表示题目中的\\(n\\).\n设\\(M\\)的特征多项式为\\(f(\\lambda)\\)，设\\(\\lambda^s=f(\\lambda)Q(\\lambda)+R(\\lambda)\\)，其中\\(\\deg R，那么因为\\(f(M)=0\\)，所以\\(M^s=R(M)\\).\n求特征多项式的话，可以把\\(\\lambda=0,1,\\ldots,n\\)带入\\(\\det(M-\\lambda I)\\)，然后插值，计算\\(R(\\lambda)\\)就直接在模\\({f(\\lambda)}\\)意义下快速幂就行了.\n发现多项式取模的一个比较简单的\\(\\mathcal O(n^2)\\)写法，设\\(f(\\lambda)=\\sum _{i=0}^na _i\\lambda^i\\)，那么\\(M^n=-\\sum _{i=0}^{n-1}\\frac{a _i}{a _n}M^i\\)，利用这个把次数不小于\\(\\deg f\\)的项全部变成次数小于\\(\\deg f\\)的项就可以了.\n代码写得比较凌乱.\n代码：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ele int #define ll long long using namespace std; #define maxn 110 #define maxm 10010 #define MOD 1000000007 struct matrix{ ele n,m,a[maxn][maxn]; inline void I(){ memset(a,0,sizeof(a)); for (int i=0; i\u0026lt;n; ++i) a[i][i]=1; } }; inline void operator+=(matrix\u0026amp;a,const matrix\u0026amp;b){ for (int i=0; i\u0026lt;a.n; ++i) for (int j=0; j\u0026lt;a.m; ++j) (a.a[i][j]+=b.a[i][j])%=MOD; } inline void operator*=(matrix\u0026amp;a,ele b){ for (int i=0; i\u0026lt;a.n; ++i) for (int j=0; j\u0026lt;a.m; ++j) a.a[i][j]=(ll)a.a[i][j]*b%MOD; } inline void operator*=(matrix\u0026amp;a,const matrix\u0026amp;b){ static matrix c; memset(c.a,0,sizeof(c.a)); c.n=a.n; c.m=b.m; for (int i=0; i\u0026lt;a.n; ++i) for (int j=0; j\u0026lt;a.m; ++j) for (int k=0; k\u0026lt;b.m; ++k) (c.a[i][k]+=(ll)a.a[i][j]*b.a[j][k]%MOD)%=MOD; a=c; } char s[maxm]; ele n,f[maxn][maxn],a[maxn][maxn],b[maxn][maxn],S[maxn][maxn],fac[maxn],ifac[maxn],c[maxn],d[maxn],e[maxn]; matrix A,B,C; inline ele pw(ele a,ele x){ ele ans=1,tmp=a%MOD; for (; x; x\u0026gt;\u0026gt;=1,tmp=(ll)tmp*tmp%MOD) if (x\u0026amp;1) ans=(ll)ans*tmp%MOD; return ans; } inline ele det(ele n,ele a[maxn][maxn]){ ele ans=1; for (int i=0; i\u0026lt;n; ++i) for (int j=i+1; j\u0026lt;n; ++j) while (a[j][i]){ ans=MOD-ans; ele tmp=a[i][i]/a[j][i]; for (int k=i; k\u0026lt;n; ++k){ (a[i][k]+=MOD-(ll)a[j][k]*tmp%MOD)%=MOD; swap(a[i][k],a[j][k]); } } for (int i=0; i\u0026lt;n; ++i) ans=(ll)ans*a[i][i]%MOD; return ans; } inline void mul(ele *a,ele *b){ static ele t[maxn]; memset(t,0,sizeof(t)); for (int i=0; i\u0026lt;=n; ++i) for (int j=0; j\u0026lt;=n; ++j) (t[i+j]+=(ll)a[i]*b[j]%MOD)%=MOD; ele invcn=pw(c[n],MOD-2); for (int i=n*2; i\u0026gt;=n; --i){ ele tmp=(ll)invcn*t[i]%MOD; for (int j=1; j\u0026lt;=n; ++j) (t[i-j]+=MOD-(ll)tmp*c[n-j]%MOD)%=MOD; t[i]=0; } memcpy(a,t,sizeof(ele)*(n+1)); } int main(){ scanf(\u0026#34;%s%d\u0026#34;,s,\u0026amp;n); for (int i=0; i\u0026lt;n; ++i) for (int j=0; j\u0026lt;n; ++j) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]); for (int i=0; i\u0026lt;=n; ++i){ memcpy(b,a,sizeof(a)); f[0][i]=det(n,b); for (int j=0; j\u0026lt;n; ++j) (a[j][j]+=MOD-1)%=MOD; } for (int i=1; i\u0026lt;=n; ++i) for (int j=0; j\u0026lt;=n-i; ++j) f[i][j]=(f[i-1][j+1]-f[i-1][j]+MOD)%MOD; for (int i=0; i\u0026lt;n; ++i) (a[i][i]+=n+1)%=MOD; memset(S,0,sizeof(S)); S[0][0]=1; for (int i=1; i\u0026lt;=n; ++i){ S[i][0]=0; for (int j=1; j\u0026lt;=i; ++j) S[i][j]=(S[i-1][j-1]+(ll)S[i-1][j]*(i-1)%MOD)%MOD; } fac[0]=1; for (int i=1; i\u0026lt;=n; ++i) fac[i]=(ll)fac[i-1]*i%MOD; ifac[n]=pw(fac[n],MOD-2); for (int i=n-1; ~i; --i) ifac[i]=(ll)ifac[i+1]*(i+1)%MOD; memset(c,0,sizeof(c)); for (int i=0; i\u0026lt;=n; ++i){ for (int j=i,ct=1; ~j; --j,ct=MOD-ct) (c[j]+=(ll)S[i][j]*f[i][0]%MOD*ifac[i]%MOD*ct%MOD)%=MOD; } memset(d,0,sizeof(d)); d[1]=1; memset(e,0,sizeof(e)); e[0]=1; ele L=strlen(s); for (int i=L-1; ~i; --i){ if (s[i]==\u0026#39;1\u0026#39;) mul(e,d); mul(d,d); } A.n=A.m=n; for (int i=0; i\u0026lt;n; ++i) for (int j=0; j\u0026lt;n; ++j) A.a[i][j]=a[i][j]; B.n=B.m=n; B.I(); C.n=C.m=n; memset(C.a,0,sizeof(C.a)); for (int i=0; i\u0026lt;n; ++i){ if (e[i]){ B*=e[i]; C+=B; B*=pw(e[i],MOD-2); } B*=A; } for (int i=0; i\u0026lt;n; ++i){ for (int j=0; j\u0026lt;n; ++j) printf(j?\u0026#34; %d\u0026#34;:\u0026#34;%d\u0026#34;,C.a[i][j]); puts(\u0026#34;\u0026#34;); } return 0; } ","permalink":"https://seraphim.rocks/posts/bzoj4162/","tags":["题解","bzoj","线性代数"],"title":"bzoj4162题解"},{"categories":null,"contents":"好久没怎么做题了，做道水题练练手.\n\\[ 记$f(n)=\\sum _{i=1}^ni[\\gcd(i,n)=1]$，那么当$n1$的时候均有$f(n)=\\frac{n\\varphi(n)}{2}$，而答案即为$n\\sum _{d|n}f(\\frac{n}{d})$. 预处理欧拉函数就可以了. 代码： ```cpp #include  #include  #include  #define ele long long using namespace std; #define maxn 1000010 ele n,pcnt,plst[maxn],phi[maxn]; bool flag[maxn]; inline ele f(ele n){ return n==1?1:n*phi[n]/2; } int main(){ freopen(\"lcm.in\",\"r\",stdin); freopen(\"lcm.out\",\"w\",stdout); pcnt=0; phi[1]=1; memset(flag,0,sizeof(flag)); for (int i=2; i","permalink":"https://seraphim.rocks/posts/loj6375/","tags":["题解","loj","数论","智力康复"],"title":"loj6375题解"},{"categories":null,"contents":"其它测试\n\\(E=mc^2\\)\n\\(\\bold{bold}\\textrm{normal}\\)\n","permalink":"https://seraphim.rocks/posts/test/","tags":["stuffs","test"],"title":"test"},{"categories":null,"contents":"在退役的边缘试探.居然rk2进入A队了，rp大概用光了吧……你看看你最近抽卡抽出来的都是什么鬼东西！D0 最后看了看板子.\nD1 早上起来感觉有点小困，但是因为要比赛了所以比较亢奋，总的来讲精神还算好.\n发现有大样例真是好评！开考之后我首先从头到尾读了一遍题目，T1的题意我纠结了一会才弄懂，感觉是个水题，T2感觉比较可做但是暂时还没什么想法，T3感觉可做而且有点想法，但是觉得可能会难打，T4似乎跟之前纪中集训的一道题很像.\n于是我就先切掉了T1，随手出了几个数据检查了一下，随了组大数据发现没RE什么的，就去搞T2，然后发现自己并不会做……我先暂时放弃了T2去看T3，发现是个三维数点，码了暴力和cdq分治套树状数组，放在一遍对拍，接着没花多少时间想出了T4，写了一发分治NTT，过了大样例. 这个时候我感觉300已经很不错了，就从头到尾静态差错了一遍. 大概到10:55的时候我感觉比较稳了，就去开T2，随便乱想了个做法，发现可以过所有的大样例，但是我怎么想都觉得是错的. 这个时候大概只剩30min了，想了想还是不写暴力去检查代码了，既然能过大样例应该暴力分还是有的？\n中午饭堂人特别多，跟着大家出去吃了，结果菜咸得吃不下……\n下午听评讲非常紧张，都没什么心情上去交流. 听说我T2的做法是对的？那岂不是可以AK？成绩单发下来，发现我真的AK了……\n晚上继续看板子，有了400分感觉压力没那么打了. 想起来比赛前我爸还跟我说反正不可能AK的blahblah……D2 按照惯例今天应该会变难，进考场之前我已经做好了打暴力的准备.\n还是按照惯例从头到尾看一遍题目. T1好像就是一个sb二合一，T2说不定可以dp/多项式什么的，T3保证高度随机那应该跟最长上升/下降子序列有关，可能不是很好想，T4……还是扔最后做吧……\n我先写完了T1，过了大样例还是感觉比较虚，怕爆longlong什么的，就从头到尾仔细算了一下. 接下来我推了一下T2的式子，发现并不需要多项式，可以直接\\(\\mathcal O(nk^2)\\)dp. 写完T2过了大样例之后感觉还能写个暴力，就顺便对拍了一下，这样应该就比较稳了. 开T3之后我卡住了一段时间，发现有贡献的左端点和右端点都期望只有\\(\\mathcal O(\\log n)\\)个，为了缩小常数我写了一个zkw，发现就算是极限数据还是跑得很快. 到这个时候大概只过了2h的样子，不过我想着D2终究会难一些，再怎么样300也很不错了，于是就没打算花太多时间做T4，简单地写了一个\\(\\mathcal O(qn^3)\\)的floyd求最小环. T4的大样例取消了，我只好自己出一些小数据测一下，感觉不是很稳，但也没办法. 剩下那2h我主要还是在各种检查代码，感觉整个赛场估计就我写代码的时间最短了.\n出考场的时候评委居然问我今天能不能AK……害怕……\n中午果断回酒店点外卖.\n下午听讲评没有前一天那么紧张了，还上去讲了一点东西. 后来发现自己讲的一个东西是错的，身败名裂……最后发现跟预期分数一样，100+100+100+50=350.\nD3 反而有点紧张，前两天运气实在太好了，直接冲上rk2，要是D3考差了岂不是糟蹋了之前的运气？\nD3没有大样例了感觉药丸. 看了一遍题，T1没什么想法，T2会50，T3可能可以想一想，T4大概不怎么可做. 我先写完了T2，仔细想了想感觉T3是个三合一，但是每一部分都比较好写，就写了一下，整整5k……这道题非常地不好拍，我先把dp改成暴力，没拍出什么错. 我纠结了一下还是写了一个纯暴力，结果一拍就拍出错了. 改完之后就怎么也查不出错误了. 但是一方面这道题随机数据不怎么强，另一方面我一开始退出来的结论很难通过对拍验证，我就前前后后检查了很长一段时间. 差不多只剩1h的时候我开始想T1，结果想出来不够时间打了，还好60分非常好写.\n出考场之后，cjb：怎么样写完了吗？我：？？？\n下午一回来已经看见有评委拿着折算分的表了，我拿到了预期的210分，最后的折算分仍然是rk2. rk3只比我低0.5分左右，真是惊险……\nD4 上去领了四次奖……（GDOI+校团体+市团体+省队）拿奖拿到手软!今天广州市是市团体第一名，作为今年广州市的第一名有幸上台捧杯.\n搞了这么多年终于进省队了，还是rk2，也算是努力有了一定的回报吧. 不过也不能满足于此，接下来的apio和noi还要继续加油.\n 虽然有很多人喷今年的题目辣鸡，我感觉总的来讲题目质量还是很不错的，不小心出到了原题那也是没办法的事，反正那几道题都挺不错的……n合一有一点点让人不爽，但至少今年这些题目打起来都挺舒服的.\n","permalink":"https://seraphim.rocks/posts/gdoi2018/","tags":["stuffs"],"title":"GDOI2018退役失败记"},{"categories":null,"contents":"我好菜啊……\n4-10 炸了炸了……\nT1 我算是想出来了，但是考场上没有调出来，一个是因为感觉比较工业所以总是写一会纠结一会要不要写下去，另外也是因为有些细节我稍微想复杂了一些. 大概思路是，从小到大枚举\\(a _S\\)，与此同时从大到小枚举\\(b _S\\)，每次就尝试把\\(b _S\\)减少1，也就是删掉\\(b _x=b _S\\)的\\(x\\)，然后看看还有没有点数不小于\\(k\\)的联通块. 维护联通块大小的话可以用lct：每条边的权值看成两个端点\\(b\\)的较大值，很容易证明整个联通块上只有最小生成树上面的边是有用的，这个就是简单的lct问题了.\n最小化\\(\\max\\{a\\}+\\max\\{b\\}\\)这样的问题，经常要从小到大枚举\\(a\\)，然后求\\(\\max\\{b\\}\\)的最小值，这是我以前就知道的. 求\\(\\max\\{b\\}\\)的最小值的时候，以前我做的题都是可以直接求的，而在这道题里面可以从大到小枚举，每次尝试将其减小直到不可行，这个思路我以前没有想到过.\nT2 我已经注意到一个很关键的地方，就是强联通块的数量+1=划分的方案数，这里划分指的是把点划分成\\(S\\)和\\(T\\)两个集合（可以为空），对\\(\\forall x\\in S,~y\\in T\\)有\\((x,y)\\in E\\). 可能是T1做得不顺利，我没有想到将其写成\\(x+1=\\sum _{S\\cup T=U,~S\\cap T=\\emptyset}\\prod _{x\\in S}\\prod _{y\\in T}[(x,y)\\in E]\\)的形式（\\(U\\)为所有点构成的集合），这样两边再求一下期望就可以得到\\(E(x)+1=\\sum _{S\\cup T=U,~S\\cap T=\\emptyset}\\prod _{x\\in S}\\prod _{y\\in T}\\textrm{Pr}((x,y)\\in E)\\)，考虑到输入只会给定m条边，其它边都是\\(\\frac{1}{2}\\)，可以记\\(f _{x,y}=2\\textrm{Pr}((x,y)\\in E)\\)，即有\\(E(x)+1=\\sum _{S\\cup T=U,~S\\cap T=\\emptyset}2^{-|S|(n-|S|)}\\prod _{x\\in S}\\prod _{y\\in T}f _{x,y}\\).\n考虑怎么算这个东西，分开考虑输入给定的边构成的每个联通块，那么任何一个联通块的点数都不超过20，让\\(g _i=\\sum _{S\\cup T=U^\\prime,~S\\cap T=\\emptyset,~|S|=i}\\prod _{x\\in S}\\prod _{y\\in T}f _{x,y}\\)，点数很少可以直接枚举\\(S\\)然后暴力计算出来（这里\\(U^\\prime\\)代表一个联通块里的所有点构成的集合）. 让\\(h _i=\\sum _{S\\cup T=U,~S\\cap T=\\emptyset,~|S|=i}\\prod _{x\\in S}\\prod _{y\\in T}f _{x,y}\\)，容易发现\\(h\\)就是每个联通块的\\(g\\)的卷积，同样可以暴力计算，最后答案即为\\(\\sum h _i2^{-i(n-i)}\\).\n4-11 AK辣！不过能A掉T2也是因为数据很水，要卡还是能卡成50分的.\nT1 水题\nT2 我用奇怪的分治AC了，让solve(l,r,hl,hr)表示处理\\([l,r]\\)这个区间，区间左右的石柱（即\\(l-1\\)和\\(r+1\\)）高度为\\(h _l\\)和\\(h _r\\). 那么如果\\(\\max _{l\\le i\\le r}\\{a _i\\}\\le\\min\\{h _l,h _r\\}\\)，就可以直接返回答案，否则找出区间中最高的石柱，然后向两边分治. 在数据随机的情况下，这么做是\\(\\mathcal O(q\\log n)\\)的.\n其实只要让\\(a _i\\)单调就可以卡掉这个做法……正解是记\\(h _i\\)为第\\(i\\)列的最高位置（包括水），那么易知\\(h _i\\)是单峰的，而答案就是\\(\\sum(h _i-a _i)\\). 用两个set来维护\\(h _i\\)就可以了，具体细节有一点多，大概是维护\\(a _i\\)从左到右和从右到左的LIS，设其下标序列为\\(S _1,~S _2\\)，那么\\(\\sum h _i=\\sum a _i(S _{1,i+1}-S _{1,i})+\\sum a _i(S _{2,i}-S _{2,i+1})-n\\max _{i=1}^n\\{a _i\\}\\)（\\(S _1,~S _2\\)都要包含\\(0\\)和\\(n+1\\)）.\nc++的reverse_iterator也不知道发生了什么完全不能用，浪费我一个下午……\nT3 cf原题\n4-12 辣鸡题意不清……不过也是我没认真读\nT1 按\\(a\\)排序，相同的话坐标较小的排在前面，然后\\(f _i=\\max\\{f _j+\\frac{(i-j)(i-j-1)}{2}\\}\\)，把括号拆开之后发现对每个\\(j\\)都是关于\\(i\\)的一条直线，用lych线段树维护即可，虽然是\\(\\mathcal O(n\\log^2 n)\\)，但常数比较小，用io优化可以卡过去.\n然后我就拿了18分，原来可以TM一个都不选. T2 首先可以想到拆开每一位，那么每次操作就是模2，循环卷积意义下乘\\(f(z)=1+\\frac{1}{z}+\\cdots+\\frac{1}{z^{k-1}}\\). 这个可以直接用FFT来做，不过\\(\\log\\)太多了……我只拿了60分. 注意到模2意义下多项式有一些很好的性质，比方说\\(f^2(z)\\equiv f(z^2)\\pmod{2}\\). 于是\\(f^{2^t}(z)\\)都是很好求的. 这个时候可以发现其实没有必要使用多项式，进行\\(2^t\\)之后的结果就是\\(y _i=\\oplus _{j=0}^{k-1}x _{(i+j\\cdot 2^t)\\mod{n}}\\)（这是因为\\(f^{2^t}(z)=\\sum _{j=0}^{k-1}z^{-j\\cdot 2^t}\\)）. 然后这个可以对每个环求前缀和从而\\(\\mathcal O(n)\\)求出来，总的时间复杂度为\\(\\mathcal O(n\\log T)\\).\nT3 可以写出一个暴力的dp方程\\(f _{i,j}=\\max\\{f _{k,j-1}+\\text{val}(k,i)\\}\\)，这里\\(f _{i,j}\\)表示只考虑\\(r _w\\le i\\)的区间，选\\(j\\)个点的答案. 我一开始的想法是决策单调性dp，但这样是两个\\(\\log\\)的，事实上\\(\\text{val}(k,i)\\)可以用线段树来维护，当\\(i\\)增加的时候只需要做一个后缀加.\n关键应该是把\\(m\\)优化掉. 如果取消\\(m\\)的限制的话，dp方程的第二维可以直接去掉，这样复杂度里的\\(m\\)就没有了，这种时候可以使用这样一种套路：记选k个点的最优解为\\(\\text{ans}(k)\\)，那么有\\(\\text{ans}(k+1)-\\text{ans}(k)\\le\\text{ans}(k)-\\text{ans}(k-1)\\)，那么可以记\\(c(k)=\\text{ans}(k)-\\lambda k\\)，那么\\(c(k+1)-c(k)=\\text{ans}(k+1)-\\text{ans}(k)-\\lambda\\)，即\\(\\text{ans}(k+1)-\\text{ans}(k)=\\lambda\\)的时候\\(c(k)\\)取到最大值，那么二分这个\\(\\lambda\\)，使\\(c(k)\\)取最大值时\\(k=m\\)，即可得到答案为\\(c(m)+\\lambda m\\). \\(c(k)\\)相当于每选一个点要付出\\(\\lambda\\)的代价，问最大收益，可以用一个类似的dp来解决. 具体实现起来还有一些细节. 现在复杂度是\\(\\mathcal O(n\\log n\\log x)\\)，据说常数比较不能AC.\n接下来只能考虑优化dp了. 注意到对\\(x，一旦\\(f _x+v _x\\le f _y+v _y\\)，那\\(x\\)求再也不能成为最大值了，于是我们可以维护\\(f _x+v _x\\)的差分，一旦某个位置非负，那就可以把前面的位置合并进来，这个用并查集来维护. 有几个细节，一个是具体实现的时候我们应该求出最大化收益的时候选出的最大点数，所以差分刚好为0要合并前面的时候，还要注意处理一下. 另外，应该让\\(f _0+v _0=\\lambda\\)，这样在此处转移就相当于一个点都不选的情况（区间从1开始）. 第一次写起来真的挺恶心的……这种一堆区间然后dp的问题用左闭右开区间似乎会方便一点？\n4-13 炸了炸了……\nT1 强行线性基硬搞的话\\(\\log\\)应该太多了所以过不了. 我们把询问离线，按右端点排序，那么就是要维护\\(f(j,i)\\)表示\\(j\\)到\\(i\\)的线性基，支持把\\(i\\)右移. 首先注意到\\(j\\)左移的时候，相当于不断往线性基里面加数，所以不同的\\(f(j,i)\\)只有\\(\\mathcal O(\\log a)\\)个，考虑维护这些线性基和它们的端点，每次\\(i\\)右移的时候，存在一个\\(j _0\\)，对\\(j，\\(f(j,i)\\)不变，对\\(j\\ge j _0\\)，\\(f(j,i)\\)相当于插入一个数，直接维护就好了. 这样的复杂度是\\(\\mathcal O(n\\log^2 a+q\\log a)\\).\n上面那个做法的瓶颈在于维护\\(\\mathcal O(\\log a)\\)个线性基. 这些线性基的左端点肯定是线性无关的，从右到左线性基的变化其实就是依次加入这些端点，所以可以考虑把这些端点放入一个线性基里面，而且只维护这个线性基. 这么做的问题是，放进线性基里面就不能区分它们的位置了，所以没办法查询，这里要用到一个套路，如果\\(x，那么所有包含\\(a _x\\)的查询肯定包含\\(a _y\\)，所以把\\(a _x\\)异或上\\(a _y\\)肯定不会有影响，所以我们维护线性基的时候可以多维护一个位置，插入一个数\\(x\\)的时候，如果到了某一位有数，就把位置靠后的放入线性基，靠前的异或上靠后的然后继续往下看. 插入成功了之后不能用较小的数的去消这个数，也不能用这个数去消较大的数.\n感觉讲不清楚，贴段代码吧……\ninline ele getv(ele x,ele i){ return (x\u0026gt;\u0026gt;i)\u0026amp;1; } inline void add(ele x,ele j){ for (int i=W-1; ~i; --i) if (getv(x,i)){ if (b[i]){ if (j\u0026gt;c[i]) swap(b[i],x),swap(c[i],j); x^=b[i]; } else{ b[i]=x; c[i]=j; break; } } } 这整一套思路都非常巧妙非常神仙啊，先当做查询区间线性基的一个套路记下来吧.\nT2 恍惚间回到了GDKOI2018 D1T1……GDKOI的时候，我写的是一次更新一整段线路，这回一开始也是，结果都死活TLE卡不过去，后来改成每次只更新下一个站就飞快地AC了……叫我整段小天才！T3 题目可以转化成给你\\(r\\)组边，每组至多选一条，问不出现环的情况下最多选多少条边. 考虑每次增加一组边，然后钦定一条加进去，如果没有出现环就不管了，否则的话枚举删掉环上的一条边，再尝试把跟它同组的另一条边钦定加进去. 这就跟找增广路一样. 复杂度\\(\\mathcal O(r^3)\\).\n4-14 神仙题神仙题……\n晚上打了场计蒜客的比赛，进了前200似乎有衣服拿？其实我发挥得挺差的，G没注意到会爆long long，又不知道unsigned long long已经到了\\(10^{19}\\)，结果耽搁了好久. B用bitset存边表但是没有清空，每次只是把邻接矩阵读进来，这样多组数据后一组的n比前一组小的时候就没有清空，后面and起来再算1的个数的时候就会出问题. C就是一个很简单的FWT，不知道为什么没想到.\nT3 终于知道这种问题怎么做了！\n首先不考虑取的树的个数的限制，那么答案就是循环卷积意义下\\([x^k]\\prod _{i=0}^{n-1}(1+x^i)\\). 因为DFT本身就是循环卷积，所以可以考虑用IDFT来算，记\\(f(x)=\\prod _{i=0}^{n-1}(1+x^i)\\)，答案就是\\(\\sum _{i=0}^{n-1}f(\\omega _n^i)\\omega _n^{-ik}\\).\n\\(x^n-1=\\prod (x-\\omega _n^i)\\)，这是因为你把\\(\\omega _n^i(i=0,1,\\ldots,n-1)\\)代入，两边都是0. 让\\(x=-1\\)，即有\\(1-(-1)^n=\\prod(1+\\omega _n^i)\\)，那么答案就可以继续化为\n\\[ 记$s(n,k)=\\sum _{\\gcd(i,n)=1} \\omega _n^{ik}$，后面那个东西就是$s(\\frac{n}{d},k)$，可以莫比乌斯反演搞出来. 现在考虑怎么加上取的个数的限制，有一个套路，就是多加一个元，即计算$[x^ky^m]\\prod _{i=0}^{n-1}(1+x^iy)$，这里只有$x$是循环卷积，把$x$看成主元，使用几乎完全相同的推导，得到答案是$[y^m]\\sum (1-(-y)^{n/d})^ds(\\frac{n}{d},k)$. 二项式展开需要组合数，可以分段打阶乘表来解决. ## HNOI 为什么没有日期呢？因为我忘了是哪天了. ### D1T1 这个做法真神仙！ 从后往前考虑每个操作，如果某个位置and了0或者or了1，那么前面的操作就无关紧要了，或者说这一位已经被确定下来了. 于是可以把每个二进制位上的$n$个操作从后往前看成一个01串，然后插到一棵trie里面，考虑在trie里面从上往下走，如果这一步是and，那么整个左子树里的位置都被确定下来了，否则整个右子树里的位置都被确定下来了. 而你走到NULL或者一个叶子，就意味着所有的位置都确定下来了，于是本质不同的方案只有$\\mathcal O(nm)$个，把这些方案都找出来，然后把他们按照钦定哪些位置为1分类，存到hash表里面，询问的时候就可以直接在hash表里面查. 如何hash位置集合？给每个位置分配一个$[0,2^{64})$的整数作为权值，位置集合的hash就是所有位置的权值异或起来，可以证明这样冲突的概率很小. ### D1T2 首先是把序列倍长，很容易（据说这其实是难点）推出要最小化$i+\\max _{i\\le j\\le i+n-1}\\{T _j-j\\}$，这个可以用单调栈很容易地dp出来，接着可以发现对答案有贡献的$T _j-j$一定是最右边的一个，它左边第一个大于它的，以此类推……然后这就非常楼房重建了. 我考场上头铁想用线段树维护结果没写出来. 楼房重建可以分块啊！贼好写啊！sbwhj！理论上每个块的大小为$\\sqrt{n\\log n}$的时候跑得最快，但是似乎把块只开$\\sqrt n$跑得要快很多，看来以后各种分块还是要看数据调整块的大小. 还有一些小优化：如果有一块最大值比右边的最大值小，那就可以直接跳过而不需要在块内二分；最后有很多块可以不在块内二分就跳过，因为$i  n$的时候对答案没有贡献. ### D1T3 kernelization真的太妙了，贴个[链接](https://www.zhihu.com/question/272303098/answer/367368615). ## 4-17 可能是正好太困了，发挥极差. 以后一定要记住题目难度与顺序无关. 一场比赛T4一样可能很可做，T1该弃还是要弃，没有必要慌，像今年GDKOID2，像今天的T4，似乎今年HNOID1T1也是一天里面最难的. 对拍有的时候也是不靠谱的，像T1我就有错没有拍出来，所以肉眼检查、自己出数据也是很重要的，特别是给自己程序加了个优化之类的时候，一定要想清楚，我T1炸了也有一部分原因是这个. ### T1 成功读错题，不知道为什么产生了一种错觉，代价加起来不会超过$P$. 这是一个典型的树上背包问题，让$f_{i,j}$表示以$i$为根的子树里代价恰好为$j$的最大收益，我以前一直只会把子树的$f$卷起来来转移，不过启发式合并一发还是可以水过去的. 事实上可以用$f _{i,j}$表示dfs序上只考虑$i$以前的点，代价恰好为$j$的时候的最大收益，那么选$i$就把背包转移到dfs序上下一个点，否则就跳过整棵子树，也就是dfs序上的整段. ### T2 想复杂了. 旋转的时候中序遍历不变，子树权值和只有两个点会被改变，每次询问就是中序遍历上一段区间的乘积. ### T3 一眼就能看出来是跟$g(n)=n^m$卷起来做杜教筛，关键是怎么求$m$次方的前缀和. 不知道为什么我以前听说的方法都是满页数学公式，各种多项式，反而不知道这么一个简单的方法：显然这是一个$m+1$次的多项式，把它在$0,1,\\ldots,m+1$处的点值线性预处理出来，然后就可以插值了. 因为选出的点的特殊性，分母处的$\\prod _{1\\le i\\le n,~i\\neq k}(x _k-x _i)=k!(m+1-k)!$，预处理阶乘之后可以$\\mathcal O(1)$求出来. 最后一点空间卡得很近，出题人想强迫你写多点求值，但是可以各种卡常卡空间+预处理$\\mathcal n^{\\frac{2}{3}}$的答案+预处理更大范围内的$m$次方前缀和压线A掉. 卡空间的方法大概有这么几个：筛$\\mu(i)i^m$的时候不额外用一个数组来存是否是质数，而是直接使用存答案的数组，一开始全部置为-1，那某个位置不为0的时候显然就已经被筛掉了；存质数的数组只需要开到$\\mathcal O(\\frac{n}{\\ln n})$. ### T4 简单计数题，把$(0,0)$也看成不合法的向量，容斥一发，计算不考虑不合法向量随便走的方案数时，可以发现两个坐标是独立的，于是分开来dp，再用前缀和优化一下转移. ## 4-18 还是很困……又挂一场. 希望只是困的问题吧…… T1我已经想到了做法，但是没有注意到可以离线，而在线的标准做法太难打，就打了个水法，结果就被卡掉了. 说到底还是我的基础不够扎实，没有想到可以离线来简化问题.T2的式子我推了太久，也导致了T1我没时间打正解，如果基础再扎实一点，再冷静一点，应该能推得更快，能注意到更简洁的做法，所以以后在考场上还是需要更平稳一点的心态，思考再细致一点，不要无脑往一个方向钻，当然太困了没办法集中精力也是原因之一，当时想边界情况的时候就死活想不清楚. ### T1 其实就是要求每个子串出现次数的平方和，如果$n=1$的话后缀自动机随便做，有多个的话其实就是要建一个广义后缀自动机然后依次加入每个字符串，但是带修改的时候，直接暴力维护每个节点代表的串的出现次数是会被卡的. 这道题可以离线把整个广义后缀自动机建好，再用树链剖分来维护parent树，如果强制在线的话就只能上LCT了. 据说有$\\mathcal O(L\\sqrt L)$的水法？ ### T2 考场上把式子推了出来，但是比标算繁琐一些，而且不够时间写分治FFT了，就只好交了一发暴力的dp，结果看错了范围，最后还交错了程序…… 感觉像这种题，要你算一个绕来绕去的奇奇怪怪的东西，很可能会有优美一些的意义，比方说这道题，每次操作的时候还要去掉这个数，把其他的数乘起来，就显得很难表示，我直接硬推也推出来了，但是就麻烦了很多. 事实上可以注意到，每一轮的伤害其实就是$\\prod A _i$的减少量，所以只需要求最后$\\prod A _i$的期望，推出来就是$\\prod A _i-\\frac{k!}{n^k}[z^k]e^{nz}\\prod(A _i-z)$，非常地好算. 我考场上推出来的做法是记$f(z)=\\prod(A _i-z)\\sum\\frac{1}{A _i-z}$，然后计算$\\sum \\frac{[z^r]f(z)}{n^{r+1}}\\sum _{i=0}^{k-1}i^{r\\downarrow}$，这里$\\sum _{i=0}^{k-1} i^{r\\downarrow}=\\sum _{i=0}^{k-1} \\frac{(i+1)^{r+1\\downarrow}-i^{r+1\\downarrow}}{r+1}=\\frac{k^{r+1\\downarrow}}{r+1}$，这个求和的方法我考场上一时慌张居然没想到……我好菜啊…… 有没有dalao愿意看看我这个做法对不对啊.  ### T3 肯定只有两端会往回走，中间都是一个方向上的，然后应该可以dp出来. 细节好多不想写…… ### T4 神仙题. 输出Infinity有20分.  ## 4-19 开始的时候还是困，头昏脑涨地想了一会，然后开始头铁码T3，等码出来+卡常卡进去之后头非常疼，时间也不多了，结果其他题的暴力没有打好. 以后可能还是要调整一下策略，说不定需要先稳住暴力分再去码正解？ 以后考前一定要尽量休息好. ### T1 首先是一个最小割模型的套路，如果有若干个物品，第$i$个有$p _i$种决策方案，分别会得到一定的收益，决策之间有一些制约关系. 可以把$i$拆成$p _i-1$个点$a _{i,0},a _{i,1},\\ldots,a _{i,p _i-2}$，相邻两个点连边，源点向$a _{i,0}$连边，$a _{i,p _i-2}$向汇点连边，割掉一条边就代表一种决策. 决策之间的制约关系，像某个点的决策编号比另一个点靠前，某个点的决策编号至少比另一个点靠前$k$位之类的，就可以通过在某些点之间连边来体现. 以假定选取获得了所有正的收益，边权即为这么决策得不到的收益，然后算最小割即可. 回去要好好看一下网络流的各种模型. 这道题里面，对每个$x _i$，可以认为它有3种决策：在最大子段前，在最大子段里，在最大子段后. 对于给定的每条边$(u,v)$，可以看作$u$的决策编号不能在$v$之后. 这样就能转化为最小割模型来做了. ### T2 考场上我已经想到了用莫比乌斯反演转化为求$k|\\gcd(u,v)$的路径条数，结果没好好想下去. 可以发现有平方因子的因数都是没有贡献的，而$10^6$以内的数最多有$c=7$个素因数，所以每个数最多有$2^c=128$个对答案有贡献的约数. 先考虑没有修改的情况，预处理出$S _d$表示权值被$d$整除的边的集合，对于每个非空且满足$\\mu(d)\\neq 0$的$S _d$，用一个并查集统计答案就可以了. 注意到每条边之多出现在$2^c$个满足$\\mu(d)\\neq 0$的$S _d$中，复杂度为$\\mathcal O(2^cn\\alpha(n))$. 考虑在线，我的第一反应是按时间分治，可是这个东西好像不能很方便地加边，更不用说撤销. 注意到$q$非常小，因而受到修改操作影响的边也非常少，可以把$S _d$中受操作影响和不受影响的边分开来存，对于每个$d$，先只把不受影响的边加进去，然后枚举$q+1$时间点，对每个时间点，加入受影响且边权被$d$整除的边，统计答案再撤销，去计算下一个时间点. 因为要撤销所以并查集不能路径压缩了，复杂度为$\\mathcal O((n+q^2)2^c\\log n)$. ### T3 数位dp的做法还是比较容易看出来的，正解非常神仙. ### T4 先坑着. \\]\n","permalink":"https://seraphim.rocks/posts/2018-4jz/","tags":["题解","jzoj"],"title":"2018-4纪中集训总结"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","permalink":"https://seraphim.rocks/search/","tags":null,"title":"Search Results"}]